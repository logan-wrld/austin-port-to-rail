<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port of Houston Map - AIS Tracking</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
        #map { height: 100vh; width: 100%; }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 280px;
        }
        .info-panel h2 { font-size: 16px; margin-bottom: 8px; color: #1a365d; }
        .info-panel p { font-size: 12px; color: #666; margin-bottom: 5px; }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; margin: 5px 0; font-size: 11px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .legend-ship { width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 14px solid #f6ad55; margin-right: 8px; }
        .terminal { background: #e53e3e; }
        .container { background: #3182ce; }
        .facility { background: #38a169; }
        .ship { background: #f6ad55; }
        
        .controls { margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee; }
        .btn {
            display: inline-block;
            padding: 8px 12px;
            background: #3182ce;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .btn:hover { background: #2c5282; }
        .btn:disabled { background: #a0aec0; cursor: not-allowed; }
        .btn.danger { background: #e53e3e; }
        .btn.danger:hover { background: #c53030; }
        
        .ship-count { 
            background: #edf2f7; 
            padding: 8px 12px; 
            border-radius: 4px; 
            margin-top: 8px;
            font-size: 12px;
        }
        .ship-count strong { color: #2d3748; }
        
        .status { font-size: 11px; color: #718096; margin-top: 8px; }
        .status.loading { color: #3182ce; }
        .status.error { color: #e53e3e; }
        .status.success { color: #38a169; }
        
        .ship-icon {
            background: none;
            border: none;
        }
        
        .vessel-popup { min-width: 200px; }
        .vessel-popup h3 { margin: 0 0 8px 0; color: #1a365d; font-size: 14px; }
        .vessel-popup .detail { font-size: 12px; margin: 4px 0; color: #4a5568; }
        .vessel-popup .detail strong { color: #2d3748; }
        .vessel-type { 
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .type-cargo { background: #fbd38d; color: #744210; }
        .type-tanker { background: #feb2b2; color: #742a2a; }
        .type-container { background: #90cdf4; color: #2a4365; }
        .type-other { background: #cbd5e0; color: #1a202c; }
        
        /* Rail styles */
        .legend-line { width: 20px; height: 3px; margin-right: 8px; border-radius: 2px; }
        .rail-up { background: #eab308; }
        .rail-bnsf { background: #f97316; }
        .rail-other { background: #6b7280; }
        
        .rail-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 220px;
            font-size: 12px;
        }
        .rail-panel h3 { font-size: 14px; margin-bottom: 8px; color: #1a365d; }
        .rail-stats { background: #f3f4f6; padding: 8px; border-radius: 4px; margin: 8px 0; }
        .rail-stats div { margin: 4px 0; }
        .rail-toggle { margin: 8px 0; }
        .rail-toggle label { display: flex; align-items: center; cursor: pointer; margin: 4px 0; }
        .rail-toggle input { margin-right: 8px; }
        
        .rail-popup { min-width: 180px; }
        .rail-popup h4 { margin: 0 0 6px 0; color: #1a365d; font-size: 13px; }
        .rail-popup .detail { font-size: 11px; margin: 3px 0; color: #4a5568; }
        .owner-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .owner-up { background: #fef3c7; color: #92400e; }
        .owner-bnsf { background: #ffedd5; color: #9a3412; }
        .owner-other { background: #e5e7eb; color: #374151; }
        
        /* Rail node styles */
        .node-marker {
            background: #7c3aed;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .node-station {
            background: #dc2626;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .node-boundary {
            background: #0891b2;
            border: 2px solid white;
            border-radius: 50%;
        }
        .node-popup { min-width: 160px; }
        .node-popup h4 { margin: 0 0 6px 0; color: #1a365d; font-size: 13px; }
        .node-popup .detail { font-size: 11px; margin: 3px 0; color: #4a5568; }
        .node-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .badge-station { background: #fee2e2; color: #991b1b; }
        .badge-junction { background: #f3e8ff; color: #6b21a8; }
        .badge-boundary { background: #cffafe; color: #0e7490; }
        .legend-node { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; border: 1px solid white; }
        .node-junction-color { background: #7c3aed; }
        .node-station-color { background: #dc2626; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Rail Network Panel -->
    <div class="rail-panel">
        <h3>üöÇ Rail Network</h3>
        <div class="rail-stats">
            <div><strong>Total Segments:</strong> <span id="railCount">0</span></div>
            <div><strong>Total Miles:</strong> <span id="railMiles">0</span></div>
        </div>
        <div class="rail-toggle">
            <label><input type="checkbox" id="toggleRail" checked onchange="toggleRailLayer()"> Show Rail Lines</label>
            <label><input type="checkbox" id="toggleNodes" onchange="toggleNodeLayer()"> Show Rail Nodes</label>
            <label><input type="checkbox" id="toggleUP" checked onchange="filterRailByOwner()"> Union Pacific (UP)</label>
            <label><input type="checkbox" id="toggleBNSF" checked onchange="filterRailByOwner()"> BNSF Railway</label>
            <label><input type="checkbox" id="togglePTRA" checked onchange="filterRailByOwner()"> PTRA (Port Terminal)</label>
            <label><input type="checkbox" id="toggleOther" checked onchange="filterRailByOwner()"> Other Railroads</label>
        </div>
        <div class="rail-stats" style="margin-top:8px;">
            <div><strong>Rail Nodes:</strong> <span id="nodeCount">0</span></div>
            <div><strong>Stations:</strong> <span id="stationCount">0</span></div>
        </div>
        <div class="legend" style="margin-top:8px; padding-top:8px; border-top:1px solid #eee;">
            <div class="legend-item"><span class="legend-line rail-up"></span> Union Pacific</div>
            <div class="legend-item"><span class="legend-line rail-bnsf"></span> BNSF Railway</div>
            <div class="legend-item"><span class="legend-line" style="background:#3b82f6"></span> PTRA (Port Terminal)</div>
            <div class="legend-item"><span class="legend-line rail-other"></span> Other Railroads</div>
            <div class="legend-item"><span class="legend-node node-junction-color"></span> Junction Node</div>
            <div class="legend-item"><span class="legend-node node-station-color"></span> Passenger Station</div>
        </div>
    </div>
    
    <div class="info-panel">
        <h2>üö¢ Port of Houston</h2>
        <p>AIS Ship Tracking</p>
        
        <div class="ship-count">
            <strong>Vessels Tracked:</strong> <span id="shipCount">0</span>
        </div>
        
        <div class="controls">
            <button class="btn" id="refreshBtn" onclick="loadAISData()">üîÑ Refresh</button>
            <button class="btn" id="autoRefreshBtn" onclick="toggleAutoRefresh()">‚ñ∂Ô∏è Auto</button>
            <button class="btn danger" onclick="clearShips()">üóëÔ∏è Clear</button>
        </div>
        
        <div id="status" class="status">Ready to load vessels</div>
        
        <div class="data-source" style="margin-top:10px; padding:8px; background:#fffbeb; border-radius:4px; font-size:10px; color:#92400e;">
            <strong>üì° Data Mode:</strong> <span id="dataMode">Simulated</span><br>
            <span style="color:#78716c;">Ships positioned along actual shipping lanes</span>
        </div>
        
        <div class="legend">
            <div class="legend-item"><span class="legend-ship"></span> Vessels (AIS)</div>
            <div class="legend-item"><span class="legend-dot terminal"></span> Terminals</div>
            <div class="legend-item"><span class="legend-dot container"></span> Container Facilities</div>
            <div class="legend-item"><span class="legend-dot facility"></span> Other Facilities</div>
            <div class="legend-item" style="margin-top:5px; padding-top:5px; border-top:1px solid #eee;"><span class="legend-line rail-up" style="display:inline-block;"></span> Rail Network</div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize map centered on Port of Houston / Galveston Bay
        const map = L.map('map').setView([29.6, -94.85], 10);

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Layer groups
        const facilitiesLayer = L.layerGroup().addTo(map);
        const shipsLayer = L.layerGroup().addTo(map);
        const railLayer = L.layerGroup().addTo(map);
        const nodesLayer = L.layerGroup(); // Not added by default (too many nodes)
        
        // Rail data storage
        let railSegments = [];
        let railNodes = [];
        
        // Auto-refresh state
        let autoRefreshInterval = null;
        let isAutoRefreshing = false;

        // Port facilities data
        const facilities = [
            { name: "Barbours Cut Container Terminal", lat: 29.7234, lng: -95.0012, type: "terminal", desc: "Major container terminal" },
            { name: "Bayport Container Terminal", lat: 29.6234, lng: -94.9912, type: "terminal", desc: "Modern container facility" },
            { name: "Turning Basin Terminal", lat: 29.7355, lng: -95.2755, type: "terminal", desc: "General cargo terminal" },
            { name: "Care Terminal", lat: 29.7156, lng: -95.0234, type: "container", desc: "Container handling" },
            { name: "Jacintoport Terminal", lat: 29.7456, lng: -95.0834, type: "container", desc: "Break-bulk cargo" },
            { name: "Galena Park Terminal", lat: 29.7356, lng: -95.2155, type: "facility", desc: "Industrial terminal" },
            { name: "Manchester Terminal", lat: 29.7256, lng: -95.2555, type: "facility", desc: "Bulk cargo facility" },
            { name: "Greens Bayou Terminal", lat: 29.7756, lng: -95.1255, type: "facility", desc: "General cargo" },
            { name: "Galveston Wharves", lat: 29.3108, lng: -94.7872, type: "terminal", desc: "Cruise & cargo terminal" },
            { name: "Texas City Terminal", lat: 29.3834, lng: -94.9134, type: "facility", desc: "Petrochemical terminal" }
        ];

        // Color mapping for facilities
        const colors = {
            terminal: '#e53e3e',
            container: '#3182ce',
            facility: '#38a169'
        };

        // Add facility markers
        facilities.forEach(f => {
            const marker = L.circleMarker([f.lat, f.lng], {
                radius: 8,
                fillColor: colors[f.type],
                color: '#fff',
                weight: 2,
                fillOpacity: 0.8
            }).addTo(facilitiesLayer);
            marker.bindPopup(`<strong>${f.name}</strong><br>${f.desc}`);
        });

        // Draw Houston Ship Channel (extended to Gulf approach)
        const channelPath = [
            [29.0, -94.4],        // Gulf of Mexico approach
            [29.1, -94.5],
            [29.2, -94.6],
            [29.3108, -94.7872],  // Galveston
            [29.35, -94.82],
            [29.55, -94.92],
            [29.68, -94.98],
            [29.7234, -95.0012],  // Barbours Cut
            [29.7355, -95.0555],
            [29.7355, -95.1555],
            [29.7355, -95.2555],
            [29.7355, -95.2955]   // Turning Basin
        ];

        L.polyline(channelPath, {
            color: '#4299e1',
            weight: 4,
            opacity: 0.5,
            dashArray: '10, 10'
        }).addTo(facilitiesLayer).bindPopup('Houston Ship Channel');

        // Create ship icon based on heading
        function createShipIcon(heading, shipType) {
            const color = getShipColor(shipType);
            const rotation = heading || 0;
            
            return L.divIcon({
                className: 'ship-icon',
                html: `<svg width="24" height="24" viewBox="0 0 24 24" style="transform: rotate(${rotation}deg);">
                    <path d="M12 2 L18 20 L12 16 L6 20 Z" fill="${color}" stroke="#fff" stroke-width="1.5"/>
                </svg>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        // Get ship color based on type
        function getShipColor(shipType) {
            const type = (shipType || '').toLowerCase();
            if (type.includes('tanker') || type.includes('oil')) return '#e53e3e';
            if (type.includes('container')) return '#3182ce';
            if (type.includes('cargo') || type.includes('bulk')) return '#f6ad55';
            if (type.includes('tug')) return '#805ad5';
            return '#718096';
        }

        // Get vessel type class for popup styling
        function getTypeClass(shipType) {
            const type = (shipType || '').toLowerCase();
            if (type.includes('tanker')) return 'type-tanker';
            if (type.includes('container')) return 'type-container';
            if (type.includes('cargo') || type.includes('bulk')) return 'type-cargo';
            return 'type-other';
        }

        // Format speed
        function formatSpeed(speed) {
            if (!speed || speed < 0) return 'N/A';
            return `${speed.toFixed(1)} knots`;
        }

        // Update status display
        function setStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }

        // AISStream WebSocket connection (for real-time data)
        let aisSocket = null;
        const AIS_API_KEY = ''; // Get free key at https://aisstream.io
        
        // Load AIS data - tries multiple sources
        async function loadAISData() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            setStatus('Loading vessel data...', 'loading');
            
            // If we have an API key, use real-time WebSocket
            if (AIS_API_KEY) {
                connectToAISStream();
                return;
            }
            
            try {
                // Bounding box for Galveston Bay / Houston Ship Channel area
                // Extended further into Gulf of Mexico to capture approaching vessels
                const minLat = 28.8;
                const maxLat = 29.9;
                const minLon = -95.4;
                const maxLon = -94.0;
                
                // Try ArcGIS Maritime service
                const response = await fetch(
                    `https://services.arcgis.com/LBbVDC0hKPAnLRpO/arcgis/rest/services/AIS_Vessel_Tracks/FeatureServer/0/query?` +
                    `where=1%3D1&geometry=${minLon}%2C${minLat}%2C${maxLon}%2C${maxLat}&geometryType=esriGeometryEnvelope&` +
                    `inSR=4326&spatialRel=esriSpatialRelIntersects&outFields=*&returnGeometry=true&f=json`,
                    { signal: AbortSignal.timeout(8000) }
                );
                
                if (!response.ok) throw new Error('AIS API unavailable');
                
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const vessels = data.features.map(f => ({
                        lat: f.geometry.y || f.geometry.points?.[0]?.[1],
                        lng: f.geometry.x || f.geometry.points?.[0]?.[0],
                        name: f.attributes.VesselName || f.attributes.VESSEL_NAME || 'Unknown Vessel',
                        mmsi: f.attributes.MMSI || f.attributes.mmsi,
                        heading: f.attributes.Heading || f.attributes.COG || 0,
                        speed: f.attributes.SOG || f.attributes.Speed || 0,
                        type: f.attributes.VesselType || f.attributes.VESSEL_TYPE || 'Cargo',
                        destination: f.attributes.Destination || 'Unknown',
                        flag: f.attributes.Flag || '',
                        length: f.attributes.Length || 'N/A',
                        draft: f.attributes.Draft || 'N/A'
                    })).filter(v => v.lat && v.lng);
                    
                    if (vessels.length > 0) {
                        document.getElementById('dataMode').textContent = 'Live (ArcGIS)';
                        document.getElementById('dataMode').parentElement.style.background = '#d1fae5';
                        displayVessels(vessels);
                        refreshBtn.disabled = false;
                        return;
                    }
                }
                throw new Error('No vessels in response');
                
            } catch (error) {
                console.log('API unavailable, using simulation:', error.message);
                document.getElementById('dataMode').textContent = 'Simulated Demo';
                document.getElementById('dataMode').parentElement.style.background = '#fffbeb';
                displayVessels(generateSimulatedVessels());
            }
            
            refreshBtn.disabled = false;
        }
        
        // Connect to AISStream.io for real-time data
        function connectToAISStream() {
            if (!AIS_API_KEY) return;
            
            if (aisSocket) {
                aisSocket.close();
            }
            
            setStatus('Connecting to AIS stream...', 'loading');
            
            aisSocket = new WebSocket('wss://stream.aisstream.io/v0/stream');
            
            aisSocket.onopen = () => {
                // Subscribe to Houston Ship Channel area (extended into Gulf)
                const subscribeMsg = {
                    APIKey: AIS_API_KEY,
                    BoundingBoxes: [[[-95.4, 28.8], [-94.0, 29.9]]]
                };
                aisSocket.send(JSON.stringify(subscribeMsg));
                setStatus('Connected to live AIS stream', 'success');
                document.getElementById('dataMode').textContent = 'Live (AISStream)';
                document.getElementById('dataMode').parentElement.style.background = '#d1fae5';
            };
            
            const liveVessels = new Map();
            
            aisSocket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.MessageType === 'PositionReport') {
                    const pos = msg.Message.PositionReport;
                    const meta = msg.MetaData;
                    
                    liveVessels.set(meta.MMSI, {
                        mmsi: meta.MMSI,
                        name: meta.ShipName || `Vessel ${meta.MMSI}`,
                        lat: pos.Latitude,
                        lng: pos.Longitude,
                        heading: pos.TrueHeading || pos.Cog || 0,
                        speed: pos.Sog || 0,
                        type: meta.ShipType || 'Unknown',
                        destination: meta.Destination || 'Unknown',
                        flag: meta.Flag || '',
                        length: meta.Length || 'N/A',
                        draft: meta.Draught || 'N/A'
                    });
                    
                    // Update display every 10 vessels received
                    if (liveVessels.size % 10 === 0) {
                        displayVessels(Array.from(liveVessels.values()));
                    }
                }
            };
            
            aisSocket.onerror = (error) => {
                console.error('AIS WebSocket error:', error);
                setStatus('Stream error, using simulation', 'error');
                displayVessels(generateSimulatedVessels());
            };
            
            aisSocket.onclose = () => {
                setStatus('Stream disconnected', '');
            };
            
            document.getElementById('refreshBtn').disabled = false;
        }

        // Generate simulated vessels for demo purposes
        // These are realistic positions along the Houston Ship Channel
        function generateSimulatedVessels() {
            // Real vessel names that commonly visit Port of Houston
            const vesselNames = [
                'MSC AURORA', 'MAERSK SEALAND', 'EVER GOLDEN', 'CMA CGM MARCO POLO',
                'COSCO SHIPPING ARIES', 'HAPAG-LLOYD EXPRESS', 'YANG MING UNITY',
                'ONE COLUMBA', 'HYUNDAI BRAVE', 'ZIM SAVANNAH', 'OOCL ATLANTA',
                'PIL PUSAN', 'MEDITERRANEAN STAR', 'ATLANTIC VOYAGER', 'GULF TRADER',
                'HOUSTON EXPRESS', 'TEXAS ENTERPRISE', 'BAYPORT CARRIER', 'CHANNEL RUNNER',
                'GALVESTON BAY', 'LONE STAR TANKER', 'ENERGY FRONTIER', 'PETROCHEMICAL HOUSTON'
            ];
            
            const vesselTypes = ['Cargo', 'Container Ship', 'Tanker', 'Bulk Carrier', 'Chemical Tanker', 'LNG Tanker', 'Tug'];
            const destinations = ['HOUSTON TX', 'GALVESTON TX', 'TEXAS CITY TX', 'BAYPORT TX', 'BARBOURS CUT TX', 'LA PORTE TX'];
            const flags = ['US', 'PA', 'LR', 'MH', 'SG', 'HK', 'GR', 'MT', 'BS', 'CY', 'NO', 'DK'];
            
            const vessels = [];
            const numVessels = 18 + Math.floor(Math.random() * 8);
            
            // Define realistic ship positions along the actual shipping lanes
            // Extended further into Gulf of Mexico for approaching vessels
            const shipPositions = [
                // Gulf of Mexico - ships approaching from open water
                { lat: 28.95, lng: -94.35, heading: 340, zone: 'gulf' },
                { lat: 29.02, lng: -94.42, heading: 335, zone: 'gulf' },
                { lat: 29.08, lng: -94.48, heading: 332, zone: 'gulf' },
                { lat: 29.15, lng: -94.55, heading: 330, zone: 'gulf' },
                { lat: 29.22, lng: -94.62, heading: 328, zone: 'gulf' },
                // Galveston Bay approach - ships entering
                { lat: 29.28, lng: -94.68, heading: 330, zone: 'approach' },
                { lat: 29.32, lng: -94.72, heading: 330, zone: 'approach' },
                { lat: 29.36, lng: -94.76, heading: 325, zone: 'approach' },
                { lat: 29.40, lng: -94.78, heading: 320, zone: 'bay' },
                // Galveston Bay - ships transiting
                { lat: 29.45, lng: -94.82, heading: 315, zone: 'bay' },
                { lat: 29.50, lng: -94.86, heading: 310, zone: 'bay' },
                { lat: 29.53, lng: -94.88, heading: 305, zone: 'bay' },
                // Entering Houston Ship Channel
                { lat: 29.58, lng: -94.91, heading: 300, zone: 'channel' },
                { lat: 29.62, lng: -94.94, heading: 295, zone: 'channel' },
                { lat: 29.66, lng: -94.97, heading: 290, zone: 'channel' },
                // Mid channel near Bayport
                { lat: 29.69, lng: -95.00, heading: 285, zone: 'channel' },
                { lat: 29.71, lng: -95.02, heading: 280, zone: 'channel' },
                { lat: 29.72, lng: -95.05, heading: 275, zone: 'channel' },
                // Near Morgan's Point
                { lat: 29.73, lng: -95.08, heading: 270, zone: 'channel' },
                { lat: 29.73, lng: -95.12, heading: 268, zone: 'channel' },
                // Approaching Turning Basin
                { lat: 29.74, lng: -95.18, heading: 265, zone: 'upper' },
                { lat: 29.74, lng: -95.22, heading: 260, zone: 'upper' },
                { lat: 29.74, lng: -95.26, heading: 255, zone: 'upper' },
                // At terminals (stationary/slow)
                { lat: 29.72, lng: -95.00, heading: 45, zone: 'terminal', speed: 0 },
                { lat: 29.62, lng: -94.99, heading: 90, zone: 'terminal', speed: 0 },
                { lat: 29.74, lng: -95.27, heading: 180, zone: 'terminal', speed: 0.5 },
            ];
            
            for (let i = 0; i < Math.min(numVessels, shipPositions.length + 5); i++) {
                let pos;
                if (i < shipPositions.length) {
                    pos = shipPositions[i];
                    // Add small random offset for realism
                    pos = {
                        ...pos,
                        lat: pos.lat + (Math.random() - 0.5) * 0.015,
                        lng: pos.lng + (Math.random() - 0.5) * 0.015,
                        heading: pos.heading + (Math.random() - 0.5) * 15
                    };
                } else {
                    // Extra random ships - some in bay, some in Gulf approach
                    const inGulf = Math.random() > 0.5;
                    if (inGulf) {
                        pos = {
                            lat: 29.0 + Math.random() * 0.25,
                            lng: -94.3 + (Math.random() - 0.5) * 0.3,
                            heading: 320 + Math.random() * 40,
                            zone: 'gulf'
                        };
                    } else {
                        pos = {
                            lat: 29.35 + Math.random() * 0.25,
                            lng: -94.85 + (Math.random() - 0.5) * 0.2,
                            heading: 300 + Math.random() * 60,
                            zone: 'bay'
                        };
                    }
                }
                
                // Speed based on zone
                let speed;
                if (pos.speed !== undefined) {
                    speed = pos.speed;
                } else if (pos.zone === 'terminal') {
                    speed = Math.random() * 1;
                } else if (pos.zone === 'channel' || pos.zone === 'upper') {
                    speed = 6 + Math.random() * 6; // 6-12 knots in channel
                } else if (pos.zone === 'gulf') {
                    speed = 12 + Math.random() * 10; // 12-22 knots in Gulf
                } else {
                    speed = 10 + Math.random() * 8; // 10-18 knots in open water
                }
                
                const vesselType = vesselTypes[Math.floor(Math.random() * vesselTypes.length)];
                
                vessels.push({
                    mmsi: 300000000 + Math.floor(Math.random() * 99999999),
                    name: vesselNames[i % vesselNames.length],
                    lat: pos.lat,
                    lng: pos.lng,
                    heading: pos.heading,
                    speed: speed,
                    type: vesselType,
                    destination: destinations[Math.floor(Math.random() * destinations.length)],
                    flag: flags[Math.floor(Math.random() * flags.length)],
                    length: vesselType.includes('Container') ? 300 + Math.floor(Math.random() * 100) : 
                            vesselType.includes('Tanker') ? 200 + Math.floor(Math.random() * 150) :
                            vesselType.includes('Tug') ? 25 + Math.floor(Math.random() * 15) :
                            100 + Math.floor(Math.random() * 200),
                    draft: vesselType.includes('Tanker') ? 12 + Math.random() * 8 : 8 + Math.random() * 8
                });
            }
            
            return vessels;
        }

        // Display vessels on map
        function displayVessels(vessels) {
            shipsLayer.clearLayers();
            let count = 0;
            
            vessels.forEach(v => {
                // Handle different API response formats
                const lat = v.lat || v.geometry?.coordinates?.[1] || v.properties?.latitude;
                const lng = v.lng || v.geometry?.coordinates?.[0] || v.properties?.longitude;
                const name = v.name || v.properties?.name || `Vessel ${v.mmsi}`;
                const heading = v.heading || v.properties?.heading || v.cog || 0;
                const speed = v.speed || v.properties?.sog || 0;
                const type = v.type || v.properties?.shipType || 'Unknown';
                const mmsi = v.mmsi || v.properties?.mmsi || 'Unknown';
                const destination = v.destination || v.properties?.destination || 'Unknown';
                const flag = v.flag || v.properties?.flag || '';
                const length = v.length || v.properties?.length || 'N/A';
                const draft = v.draft || v.properties?.draft || 'N/A';
                
                if (!lat || !lng) return;
                
                const icon = createShipIcon(heading, type);
                const marker = L.marker([lat, lng], { icon: icon }).addTo(shipsLayer);
                
                const typeClass = getTypeClass(type);
                marker.bindPopup(`
                    <div class="vessel-popup">
                        <h3>üö¢ ${name}</h3>
                        <span class="vessel-type ${typeClass}">${type}</span>
                        <div class="detail"><strong>MMSI:</strong> ${mmsi}</div>
                        <div class="detail"><strong>Flag:</strong> ${flag || 'Unknown'}</div>
                        <div class="detail"><strong>Speed:</strong> ${formatSpeed(speed)}</div>
                        <div class="detail"><strong>Heading:</strong> ${heading ? heading.toFixed(0) + '¬∞' : 'N/A'}</div>
                        <div class="detail"><strong>Destination:</strong> ${destination}</div>
                        <div class="detail"><strong>Length:</strong> ${typeof length === 'number' ? length + ' m' : length}</div>
                        <div class="detail"><strong>Draft:</strong> ${typeof draft === 'number' ? draft.toFixed(1) + ' m' : draft}</div>
                    </div>
                `);
                
                count++;
            });
            
            document.getElementById('shipCount').textContent = count;
            setStatus(`Updated: ${new Date().toLocaleTimeString()}`, 'success');
        }

        // Clear ships from map
        function clearShips() {
            shipsLayer.clearLayers();
            document.getElementById('shipCount').textContent = '0';
            setStatus('Vessels cleared', '');
        }

        // Toggle auto-refresh
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            
            if (isAutoRefreshing) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                isAutoRefreshing = false;
                btn.textContent = '‚ñ∂Ô∏è Auto';
                setStatus('Auto-refresh stopped', '');
            } else {
                loadAISData();
                autoRefreshInterval = setInterval(loadAISData, 60000); // Refresh every 60 seconds
                isAutoRefreshing = true;
                btn.textContent = '‚è∏Ô∏è Auto';
                setStatus('Auto-refresh enabled (60s)', 'success');
            }
        }

        // ========== RAIL NETWORK DATA & VISUALIZATION ==========

        // Rail line data loaded from CSV files
        let railLinesData = [];
        let nodeCoordLookup = {}; // Map of FRANODEID -> {x, y}

        // Load rail nodes and create coordinate lookup
        async function loadNodeCoordinates() {
            try {
                const response = await fetch('data/railroad-nodes.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');

                // Parse nodes and create lookup map
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 13) continue;

                    const nodeId = cols[1]; // FRANODEID
                    const x = parseFloat(cols[11]); // longitude
                    const y = parseFloat(cols[12]); // latitude

                    if (!isNaN(x) && !isNaN(y)) {
                        nodeCoordLookup[nodeId] = { x, y };
                    }
                }

                console.log(`Loaded ${Object.keys(nodeCoordLookup).length} node coordinates`);
                return true;
            } catch (error) {
                console.error('Error loading node coordinates:', error);
                return false;
            }
        }

        // Load rail lines from CSV
        async function loadRailLinesFromCSV() {
            try {
                // First ensure we have node coordinates
                if (Object.keys(nodeCoordLookup).length === 0) {
                    await loadNodeCoordinates();
                }

                const response = await fetch('data/texas_rail_data.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');

                railLinesData = [];

                // Parse header to get column indices
                const header = lines[0].split(',');
                const colIndex = {
                    frNode: header.indexOf('FRFRANODE'),
                    toNode: header.indexOf('TOFRANODE'),
                    owner: header.indexOf('RROWNER1'),
                    subdiv: header.indexOf('SUBDIV'),
                    miles: header.indexOf('MILES'),
                    tracks: header.indexOf('TRACKS'),
                    cntyfips: header.indexOf('CNTYFIPS')
                };

                // Houston area county FIPS codes
                const houstonCounties = ['201', '039', '071', '157', '167', '291', '321', '339', '473'];

                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 30) continue;

                    const countyFips = cols[colIndex.cntyfips];

                    // Filter to Houston/Galveston area counties
                    if (!houstonCounties.includes(countyFips)) continue;

                    const frNode = cols[colIndex.frNode];
                    const toNode = cols[colIndex.toNode];
                    const fromCoord = nodeCoordLookup[frNode];
                    const toCoord = nodeCoordLookup[toNode];

                    // Only include if we have coordinates for both nodes
                    if (!fromCoord || !toCoord) continue;

                    // Filter to Houston/Galveston Bay bounding box
                    if (fromCoord.x < -96 || fromCoord.x > -94.5 || fromCoord.y < 29 || fromCoord.y > 30.2) continue;
                    if (toCoord.x < -96 || toCoord.x > -94.5 || toCoord.y < 29 || toCoord.y > 30.2) continue;

                    railLinesData.push({
                        owner: cols[colIndex.owner] || 'OTHER',
                        subdiv: cols[colIndex.subdiv] || '',
                        miles: parseFloat(cols[colIndex.miles]) || 0,
                        tracks: parseInt(cols[colIndex.tracks]) || 1,
                        fromCoord: fromCoord,
                        toCoord: toCoord
                    });
                }

                console.log(`Loaded ${railLinesData.length} rail line segments for Houston area`);
                return railLinesData;
            } catch (error) {
                console.error('Error loading rail lines:', error);
                return [];
            }
        }
        
        // Rail owner colors
        const railColors = {
            'UP': '#eab308',      // Yellow for Union Pacific
            'BNSF': '#f97316',    // Orange for BNSF
            'PTRA': '#3b82f6',    // Blue for Port Terminal Railroad Association
            'TCT': '#6366f1',     // Indigo for Texas City Terminal
            'TXGC': '#10b981',    // Emerald for Texas & Gulf Coast
            'USG': '#6b7280',     // Gray for US Government
            'BRG': '#10b981',     // Emerald
            'AWRR': '#8b5cf6',    // Violet
            'FWWR': '#ec4899',    // Pink
            'KCS': '#dc2626',     // Red for Kansas City Southern
            'DGNO': '#0891b2',    // Cyan for Dallas Garland & Northeastern
            'default': '#6b7280'  // Gray default
        };
        
        // Get owner badge class
        function getOwnerClass(owner) {
            if (owner === 'UP') return 'owner-up';
            if (owner === 'BNSF') return 'owner-bnsf';
            return 'owner-other';
        }
        
        // Draw rail network from CSV data
        async function drawRailNetwork() {
            railLayer.clearLayers();
            railSegments = [];

            // Load rail lines if not already loaded
            if (railLinesData.length === 0) {
                document.getElementById('railCount').textContent = 'Loading...';
                await loadRailLinesFromCSV();
            }

            const showUP = document.getElementById('toggleUP').checked;
            const showBNSF = document.getElementById('toggleBNSF').checked;
            const showPTRA = document.getElementById('togglePTRA').checked;
            const showOther = document.getElementById('toggleOther').checked;

            let totalMiles = 0;
            let segmentCount = 0;

            railLinesData.forEach(rail => {
                // Filter by owner
                if (rail.owner === 'UP' && !showUP) return;
                if (rail.owner === 'BNSF' && !showBNSF) return;
                if (rail.owner === 'PTRA' && !showPTRA) return;
                if (!['UP', 'BNSF', 'PTRA'].includes(rail.owner) && !showOther) return;

                const color = railColors[rail.owner] || railColors['default'];
                const weight = rail.tracks > 1 ? 4 : 2;

                // Draw line from fromCoord to toCoord
                const coords = [
                    [rail.fromCoord.y, rail.fromCoord.x],  // [lat, lng]
                    [rail.toCoord.y, rail.toCoord.x]
                ];

                const line = L.polyline(coords, {
                    color: color,
                    weight: weight,
                    opacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(railLayer);

                // Popup with rail info
                const subdivName = rail.subdiv || 'Rail Segment';
                line.bindPopup(`
                    <div class="rail-popup">
                        <span class="owner-badge ${getOwnerClass(rail.owner)}">${rail.owner}</span>
                        <h4>üõ§Ô∏è ${subdivName}</h4>
                        <div class="detail"><strong>Owner:</strong> ${getOwnerFullName(rail.owner)}</div>
                        <div class="detail"><strong>Miles:</strong> ${rail.miles.toFixed(3)}</div>
                        <div class="detail"><strong>Tracks:</strong> ${rail.tracks}</div>
                    </div>
                `);

                railSegments.push({ line, data: rail });
                totalMiles += rail.miles;
                segmentCount++;
            });

            // Update stats
            document.getElementById('railCount').textContent = segmentCount.toLocaleString();
            document.getElementById('railMiles').textContent = totalMiles.toFixed(1);
        }
        
        // Get full railroad name
        function getOwnerFullName(code) {
            const names = {
                'UP': 'Union Pacific Railroad',
                'BNSF': 'BNSF Railway',
                'PTRA': 'Port Terminal Railroad Association',
                'TCT': 'Texas City Terminal Railway',
                'TXGC': 'Texas & Gulf Coast Railway',
                'USG': 'US Government',
                'BRG': 'Brownsville & Rio Grande',
                'AWRR': 'Austin Western Railroad',
                'FWWR': 'Fort Worth & Western Railroad',
                'KCS': 'Kansas City Southern',
                'DGNO': 'Dallas Garland & Northeastern',
                'GCSR': 'Gulf Coast Switching Railway',
                'GVSR': 'Galveston Railroad'
            };
            return names[code] || code;
        }
        
        // Toggle rail layer visibility
        async function toggleRailLayer() {
            const show = document.getElementById('toggleRail').checked;
            if (show) {
                map.addLayer(railLayer);
                await drawRailNetwork();
            } else {
                map.removeLayer(railLayer);
            }
        }

        // Filter rail by owner
        async function filterRailByOwner() {
            await drawRailNetwork();
        }
        
        // ========== RAIL NODES VISUALIZATION ==========
        
        // Load rail nodes from CSV file
        async function loadRailNodes() {
            try {
                const response = await fetch('data/railroad-nodes.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                
                // Skip header
                railNodes = [];
                let stationCount = 0;
                
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 13) continue;
                    
                    const x = parseFloat(cols[11]); // longitude
                    const y = parseFloat(cols[12]); // latitude
                    
                    // Filter to Houston/Galveston area
                    if (x < -96 || x > -94 || y < 29 || y > 30.5) continue;
                    
                    const node = {
                        objectId: cols[0],
                        fraNodeId: cols[1],
                        state: cols[3],
                        countyFips: cols[5],
                        stCountyFips: cols[6],
                        fraDistrict: cols[7],
                        passenger: cols[8],
                        stationName: cols[9],
                        boundary: parseInt(cols[10]) || 0,
                        lng: x,
                        lat: y
                    };
                    
                    railNodes.push(node);
                    if (node.stationName) stationCount++;
                }
                
                console.log(`Loaded ${railNodes.length} rail nodes, ${stationCount} stations`);
                document.getElementById('nodeCount').textContent = railNodes.length.toLocaleString();
                document.getElementById('stationCount').textContent = stationCount;
                
                return railNodes;
            } catch (error) {
                console.error('Error loading rail nodes:', error);
                return [];
            }
        }
        
        // Draw rail nodes on map
        function drawRailNodes() {
            nodesLayer.clearLayers();
            
            // Get current zoom level to adjust visibility
            const zoom = map.getZoom();
            
            // Only show nodes when zoomed in enough (too many otherwise)
            if (zoom < 11) {
                // At low zoom, just show stations
                railNodes.filter(n => n.stationName).forEach(node => {
                    addNodeMarker(node, true);
                });
            } else if (zoom < 13) {
                // Medium zoom: show stations + sample of junctions
                railNodes.forEach((node, i) => {
                    if (node.stationName || node.boundary > 0 || i % 10 === 0) {
                        addNodeMarker(node, node.stationName);
                    }
                });
            } else {
                // High zoom: show all nodes
                railNodes.forEach(node => {
                    addNodeMarker(node, node.stationName);
                });
            }
        }
        
        // Add a single node marker
        function addNodeMarker(node, isStation) {
            let className, radius, color;
            
            if (node.stationName) {
                className = 'node-station';
                radius = 8;
                color = '#dc2626';
            } else if (node.boundary > 0) {
                className = 'node-boundary';
                radius = 5;
                color = '#0891b2';
            } else {
                className = 'node-marker';
                radius = 4;
                color = '#7c3aed';
            }
            
            const marker = L.circleMarker([node.lat, node.lng], {
                radius: radius,
                fillColor: color,
                color: '#fff',
                weight: 1.5,
                fillOpacity: 0.8,
                className: className
            }).addTo(nodesLayer);
            
            // Create popup content
            let nodeType = 'Junction';
            let badgeClass = 'badge-junction';
            if (node.stationName) {
                nodeType = 'Passenger Station';
                badgeClass = 'badge-station';
            } else if (node.boundary > 0) {
                nodeType = 'Boundary Point';
                badgeClass = 'badge-boundary';
            }
            
            marker.bindPopup(`
                <div class="node-popup">
                    <span class="node-type-badge ${badgeClass}">${nodeType}</span>
                    <h4>${node.stationName || 'Rail Junction'}</h4>
                    <div class="detail"><strong>Node ID:</strong> ${node.fraNodeId}</div>
                    <div class="detail"><strong>County FIPS:</strong> ${node.stCountyFips}</div>
                    <div class="detail"><strong>FRA District:</strong> ${node.fraDistrict}</div>
                    <div class="detail"><strong>Coords:</strong> ${node.lat.toFixed(4)}, ${node.lng.toFixed(4)}</div>
                    ${node.passenger ? `<div class="detail"><strong>Service:</strong> ${node.passenger}</div>` : ''}
                </div>
            `);
        }
        
        // Toggle node layer visibility
        function toggleNodeLayer() {
            const checkbox = document.getElementById('toggleNodes');
            const show = checkbox.checked;
            
            if (show) {
                // Show nodes
                if (railNodes.length === 0) {
                    loadRailNodes().then(() => {
                        drawRailNodes();
                        if (!map.hasLayer(nodesLayer)) {
                            map.addLayer(nodesLayer);
                        }
                    });
                } else {
                    drawRailNodes();
                    if (!map.hasLayer(nodesLayer)) {
                        map.addLayer(nodesLayer);
                    }
                }
            } else {
                // Hide nodes - remove layer from map
                nodesLayer.clearLayers();
                map.removeLayer(nodesLayer);
            }
        }
        
        // Redraw nodes on zoom change
        map.on('zoomend', function() {
            const checkbox = document.getElementById('toggleNodes');
            if (checkbox && checkbox.checked && map.hasLayer(nodesLayer)) {
                drawRailNodes();
            }
        });
        
        // Initialize rail network and load data
        async function initializeMap() {
            console.log('Initializing map...');
            await drawRailNetwork();
            console.log('Rail network loaded');
            loadAISData();
        }

        // Start initialization
        initializeMap();
    </script>
</body>
</html>
