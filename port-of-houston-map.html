<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port of Houston Map - Houston & Galveston Area</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        /* Dark theme with colorful features - dark land, colorful lines */
        .leaflet-container {
            background-color: #0a0a0a;
        }
        
        /* Aggressive filter: very dark land but highly saturated colorful features */
        body.dark-theme .leaflet-tile-container img {
            filter: brightness(0.4) contrast(1.8) saturate(2.0);
        }
        
        /* Light theme - no filter */
        body.light-theme .leaflet-container {
            background-color: #f4f4f4;
        }
        
        body.light-theme .leaflet-tile-container img {
            filter: none;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 280px;
            border: 1px solid #404040;
        }

        .info-panel h2 {
            font-size: 16px;
            margin-bottom: 8px;
            color: #e0e0e0;
        }

        .info-panel p {
            font-size: 12px;
            color: #b0b0b0;
            margin-bottom: 5px;
        }

        .legend {
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 11px;
            color: #e0e0e0;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .legend-ship {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 14px solid #f6ad55;
            margin-right: 8px;
        }

        .terminal {
            background: #e53e3e;
        }

        .container {
            background: #3182ce;
        }

        .facility {
            background: #38a169;
        }

        .ship {
            background: #f6ad55;
        }

        .controls {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #404040;
        }

        .btn {
            display: inline-block;
            padding: 8px 12px;
            background: #3182ce;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }

        .btn:hover {
            background: #4299e1;
        }

        .btn:disabled {
            background: #4a5568;
            cursor: not-allowed;
            color: #718096;
        }

        .btn.danger {
            background: #e53e3e;
        }

        .btn.danger:hover {
            background: #fc8181;
        }

        .ship-count {
            background: #1a1a1a;
            padding: 8px 12px;
            border-radius: 4px;
            margin-top: 8px;
            font-size: 12px;
            border: 1px solid #404040;
        }

        .ship-count strong {
            color: #e0e0e0;
        }

        .status {
            font-size: 11px;
            color: #a0aec0;
            margin-top: 8px;
        }

        .status.loading {
            color: #63b3ed;
        }

        .status.error {
            color: #fc8181;
        }

        .status.success {
            color: #68d391;
        }

        .ship-icon {
            background: none;
            border: none;
        }

        .vessel-popup {
            min-width: 200px;
        }

        .vessel-popup h3 {
            margin: 0 0 8px 0;
            color: #e0e0e0;
            font-size: 14px;
        }

        .vessel-popup .detail {
            font-size: 12px;
            margin: 4px 0;
            color: #b0b0b0;
        }

        .vessel-popup .detail strong {
            color: #e0e0e0;
        }

        .vessel-type {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .type-cargo {
            background: #fbd38d;
            color: #744210;
        }

        .type-tanker {
            background: #feb2b2;
            color: #742a2a;
        }

        .type-container {
            background: #90cdf4;
            color: #2a4365;
        }

        .type-other {
            background: #cbd5e0;
            color: #1a202c;
        }

        /* Forecast panel styles */
        .forecast-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #2d2d2d;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 320px;
            font-size: 12px;
            border: 1px solid #404040;
        }

        .forecast-panel h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #e0e0e0;
        }

        .forecast-row {
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.6;
            border: 1px solid #404040;
        }

        .forecast-label {
            color: #b0b0b0;
        }

        .forecast-sep {
            color: #606060;
            margin: 0 8px;
        }

        .forecast-summary {
            margin-top: 6px;
            padding: 6px 8px;
            background: #1a1a1a;
            border-radius: 4px;
            font-size: 11px;
            color: #e0e0e0;
            border: 1px solid #404040;
        }

        .forecast-stats {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #404040;
            font-size: 11px;
            color: #a0aec0;
        }

        .forecast-stats div {
            margin: 3px 0;
        }

        /* Rail styles */
        .legend-line {
            width: 20px;
            height: 3px;
            margin-right: 8px;
            border-radius: 2px;
        }

        .rail-up {
            background: #eab308;
        }

        .rail-bnsf {
            background: #f97316;
        }

        .rail-other {
            background: #6b7280;
        }

        .rail-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #2d2d2d;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 220px;
            font-size: 12px;
            border: 1px solid #404040;
        }

        .rail-panel h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #e0e0e0;
        }

        .rail-stats {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            border: 1px solid #404040;
            color: #e0e0e0;
        }

        .rail-stats div {
            margin: 4px 0;
        }

        .rail-toggle {
            margin: 8px 0;
        }

        .rail-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 4px 0;
            color: #e0e0e0;
        }

        /* Light theme overrides for rail panel elements */
        body.light-theme .rail-stats {
            background: #f7fafc;
            border-color: #e2e8f0;
            color: #2d3748;
        }

        body.light-theme .rail-stats div {
            color: #2d3748;
        }

        body.light-theme .rail-toggle label {
            color: #2d3748;
        }

        .rail-toggle input {
            margin-right: 8px;
        }

        .rail-popup {
            min-width: 180px;
        }

        .rail-popup h4 {
            margin: 0 0 6px 0;
            color: #e0e0e0;
            font-size: 13px;
        }

        .rail-popup .detail {
            font-size: 11px;
            margin: 3px 0;
            color: #b0b0b0;
        }

        .owner-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .owner-up {
            background: #fef3c7;
            color: #92400e;
        }

        .owner-bnsf {
            background: #ffedd5;
            color: #9a3412;
        }

        .owner-other {
            background: #e5e7eb;
            color: #374151;
        }

        /* Rail node styles */
        .node-marker {
            background: #7c3aed;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .node-station {
            background: #dc2626;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .node-boundary {
            background: #0891b2;
            border: 2px solid white;
            border-radius: 50%;
        }

        .node-popup {
            min-width: 160px;
        }

        .node-popup h4 {
            margin: 0 0 6px 0;
            color: #e0e0e0;
            font-size: 13px;
        }

        .node-popup .detail {
            font-size: 11px;
            margin: 3px 0;
            color: #b0b0b0;
        }

        .node-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .badge-station {
            background: #fee2e2;
            color: #991b1b;
        }

        .badge-junction {
            background: #f3e8ff;
            color: #6b21a8;
        }

        .badge-boundary {
            background: #cffafe;
            color: #0e7490;
        }

        .legend-node {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid white;
        }

        .node-junction-color {
            background: #7c3aed;
        }

        .node-station-color {
            background: #dc2626;
        }

        /* Weather panel styles */
        .weather-panel {
            position: absolute;
            top: 10px;
            left: 240px;
            background: #2d2d2d;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            max-width: 320px;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid #404040;
        }

        .weather-panel h3 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #e0e0e0;
        }

        .weather-current {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .weather-current .temp {
            font-size: 32px;
            font-weight: bold;
            margin: 8px 0;
        }

        .weather-current .description {
            font-size: 14px;
            text-transform: capitalize;
            margin-bottom: 8px;
        }

        .weather-current .details {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin-top: 8px;
            opacity: 0.9;
        }

        .weather-forecast {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #404040;
        }

        .weather-forecast h4 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #e0e0e0;
        }

        .forecast-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: #1a1a1a;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid #404040;
        }

        .forecast-item .forecast-day {
            font-weight: 600;
            color: #e0e0e0;
            min-width: 80px;
        }

        .forecast-item .forecast-temp {
            color: #b0b0b0;
            font-weight: 500;
        }

        .forecast-item .forecast-icon {
            font-size: 18px;
        }

        .weather-icon {
            font-size: 48px;
            text-align: center;
            margin: 8px 0;
        }

        .weather-loading {
            text-align: center;
            padding: 20px;
            color: #a0aec0;
            font-size: 12px;
        }

        .weather-error {
            text-align: center;
            padding: 20px;
            color: #fc8181;
            font-size: 12px;
        }

        .weather-refresh-btn {
            margin-top: 8px;
            width: 100%;
        }

        .weather-overlay-toggle {
            margin-top: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            font-size: 11px;
            border: 1px solid #404040;
        }

        .weather-overlay-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 4px 0;
        }

        .weather-overlay-toggle input {
            margin-right: 8px;
        }

        /* Forecast Popup */
        .forecast-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2d2d2d;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.7);
            z-index: 2000;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            border: 1px solid #404040;
        }

        .forecast-popup.show {
            display: block;
        }

        .forecast-popup h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .forecast-popup .close-btn {
            background: #e53e3e;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 12px;
        }

        .forecast-popup .close-btn:hover {
            background: #c53030;
        }

        .forecast-popup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }

        .forecast-popup-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .forecast-popup-item .day {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .forecast-popup-item .icon {
            font-size: 32px;
            margin: 8px 0;
        }

        .forecast-popup-item .temp {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
        }

        .forecast-popup-item .desc {
            font-size: 11px;
            opacity: 0.9;
            text-transform: capitalize;
            margin-top: 4px;
        }

        .forecast-popup-item .details {
            font-size: 10px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            opacity: 0.85;
        }

        .popup-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1999;
            display: none;
        }

        .popup-overlay.show {
            display: block;
        }

        /* AI Chat Panel Styles */
        .ai-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: #2d2d2d;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            width: 380px;
            max-height: 450px;
            display: flex;
            flex-direction: column;
            border: 1px solid #404040;
        }

        .ai-panel h3 {
            font-size: 14px;
            margin: 0;
            color: #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ai-panel .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #48bb78;
            display: inline-block;
            margin-right: 6px;
        }

        .ai-panel .status-dot.offline {
            background: #fc8181;
        }

        .ai-panel .status-dot.loading {
            background: #f6e05e;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .ai-metrics {
            background: #1a1a1a;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 11px;
            border: 1px solid #404040;
        }

        .ai-metrics .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .ai-metrics .metric-label {
            color: #a0aec0;
        }

        .ai-metrics .metric-value {
            font-weight: 600;
            color: #e0e0e0;
        }

        .ai-metrics .risk-low {
            color: #38a169;
        }

        .ai-metrics .risk-medium {
            color: #dd6b20;
        }

        .ai-metrics .risk-high {
            color: #e53e3e;
        }

        .ai-chat-area {
            flex: 1;
            overflow-y: auto;
            max-height: 200px;
            margin-bottom: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 4px;
            font-size: 12px;
            border: 1px solid #404040;
        }

        .ai-message {
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            max-width: 90%;
        }

        .ai-message.user {
            background: #3182ce;
            color: white;
            margin-left: auto;
        }

        .ai-message.assistant {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #404040;
        }

        .ai-message.error {
            background: #4a1a1a;
            color: #fc8181;
            border: 1px solid #7a2a2a;
        }

        .ai-input-area {
            display: flex;
            gap: 6px;
        }

        .ai-input {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #404040;
            border-radius: 4px;
            font-size: 12px;
            background: #1a1a1a;
            color: #e0e0e0;
        }

        .ai-input:focus {
            outline: none;
            border-color: #3182ce;
        }

        .ai-input::placeholder {
            color: #606060;
        }

        .ai-send-btn {
            padding: 8px 12px;
            background: #3182ce;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .ai-send-btn:hover {
            background: #2c5282;
        }

        .ai-send-btn:disabled {
            background: #a0aec0;
            cursor: not-allowed;
        }

        .ai-quick-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .ai-quick-btn {
            padding: 4px 8px;
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            color: #b0b0b0;
        }

        .ai-quick-btn:hover {
            background: #2d2d2d;
            border-color: #606060;
        }

        /* Collapsible Panel Styles */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .panel-header h3 {
            margin: 0;
            font-size: 14px;
            color: #e0e0e0;
        }

        .collapse-btn {
            background: #1a1a1a;
            border: 1px solid #404040;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #b0b0b0;
            transition: all 0.2s ease;
        }

        .collapse-btn:hover {
            background: #2d2d2d;
            color: #e0e0e0;
            border-color: #606060;
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel-content.collapsed {
            display: none;
        }

        .panel.collapsed {
            padding: 8px 12px;
        }

        .panel.collapsed .panel-header {
            margin-bottom: 0;
        }

        /* Theme toggle button */
        .theme-toggle {
            position: absolute;
            top: 10px;
            right: 300px;
            z-index: 1000;
            background: #2d2d2d;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #e0e0e0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease;
        }

        .theme-toggle:hover {
            background: #3d3d3d;
            border-color: #606060;
        }

        .theme-toggle.light-theme {
            background: white;
            border-color: #e2e8f0;
            color: #2d3748;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .theme-toggle.light-theme:hover {
            background: #f7fafc;
            border-color: #cbd5e0;
        }

        /* Dark theme for Leaflet popups */
        .leaflet-popup-content-wrapper {
            background: #2d2d2d;
            color: #e0e0e0;
            border: 1px solid #404040;
        }

        .leaflet-popup-tip {
            background: #2d2d2d;
        }

        .leaflet-popup-close-button {
            color: #e0e0e0;
        }

        .leaflet-popup-close-button:hover {
            color: #ffffff;
        }

        /* Ensure all text in panels is visible */
        .rail-stats strong {
            color: #e0e0e0;
        }

        .forecast-content {
            color: #e0e0e0;
        }

        /* Light theme panel styles */
        body.light-theme .info-panel,
        body.light-theme .forecast-panel,
        body.light-theme .rail-panel,
        body.light-theme .weather-panel,
        body.light-theme .ai-panel {
            background: white;
            border-color: #e2e8f0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        body.light-theme .info-panel h2,
        body.light-theme .forecast-panel h3,
        body.light-theme .rail-panel h3,
        body.light-theme .weather-panel h3,
        body.light-theme .ai-panel h3,
        body.light-theme .panel-header h3 {
            color: #1a365d;
        }

        body.light-theme .info-panel p,
        body.light-theme .forecast-label,
        body.light-theme .rail-popup .detail,
        body.light-theme .node-popup .detail,
        body.light-theme .vessel-popup .detail {
            color: #4a5568;
        }

        body.light-theme .ship-count,
        body.light-theme .rail-stats,
        body.light-theme .forecast-row,
        body.light-theme .forecast-summary,
        body.light-theme .ai-metrics,
        body.light-theme .ai-chat-area,
        body.light-theme .forecast-item {
            background: #f7fafc;
            border-color: #e2e8f0;
        }

        body.light-theme .ship-count strong,
        body.light-theme .rail-stats strong,
        body.light-theme .rail-stats,
        body.light-theme .rail-stats div,
        body.light-theme .forecast-summary,
        body.light-theme .ai-metrics .metric-value,
        body.light-theme .forecast-item .forecast-day {
            color: #2d3748;
        }

        body.light-theme .rail-toggle label {
            color: #2d3748;
        }

        body.light-theme .status {
            color: #718096;
        }

        body.light-theme .status.loading {
            color: #3182ce;
        }

        body.light-theme .status.error {
            color: #e53e3e;
        }

        body.light-theme .status.success {
            color: #38a169;
        }

        body.light-theme .controls {
            border-top-color: #e2e8f0;
        }

        body.light-theme .forecast-stats,
        body.light-theme .weather-forecast {
            border-top-color: #e2e8f0;
        }

        body.light-theme .forecast-stats {
            color: #718096;
        }

        body.light-theme .ai-input {
            background: white;
            border-color: #e2e8f0;
            color: #2d3748;
        }

        body.light-theme .ai-quick-btn {
            background: #edf2f7;
            border-color: #e2e8f0;
            color: #4a5568;
        }

        body.light-theme .ai-quick-btn:hover {
            background: #e2e8f0;
        }

        body.light-theme .ai-message.assistant {
            background: white;
            color: #2d3748;
            border-color: #e2e8f0;
        }

        body.light-theme .collapse-btn {
            background: #edf2f7;
            border-color: #e2e8f0;
            color: #4a5568;
        }

        body.light-theme .collapse-btn:hover {
            background: #e2e8f0;
            color: #2d3748;
        }

        body.light-theme .legend-item {
            color: #2d3748;
        }

        body.light-theme .leaflet-popup-content-wrapper {
            background: white;
            color: #2d3748;
            border-color: #e2e8f0;
        }

        body.light-theme .leaflet-popup-tip {
            background: white;
        }

        body.light-theme .leaflet-popup-close-button {
            color: #4a5568;
        }

        body.light-theme .vessel-popup h3,
        body.light-theme .rail-popup h4,
        body.light-theme .node-popup h4 {
            color: #1a365d;
        }

        body.light-theme .data-source {
            background: #fffbeb !important;
            border-color: #fde68a !important;
            color: #92400e !important;
        }

        body.light-theme .data-source span {
            color: #78716c !important;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- Theme Toggle Button -->
    <div class="theme-toggle" id="themeToggle" onclick="toggleTheme()" title="Toggle dark/light theme">
        <span id="themeIcon">üåô</span>
        <span id="themeText">Dark Theme</span>
    </div>

    <!-- AI Analytics Panel -->
    <div class="ai-panel panel" id="aiPanel">
        <div class="panel-header">
            <h3>
                <span><span class="status-dot" id="aiStatusDot"></span>AI Analytics</span>
            </h3>
            <button class="collapse-btn" onclick="togglePanel('aiPanel')" title="Toggle panel">‚àí</button>
        </div>
        <div class="panel-content" id="aiPanelContent">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <button class="btn" style="padding:4px 8px; font-size:10px;" onclick="refreshMetrics()">Refresh</button>
            </div>

            <!-- Current Metrics -->
            <div class="ai-metrics" id="aiMetrics">
                <div class="metric-row">
                    <span class="metric-label">TEU/hour:</span>
                    <span class="metric-value" id="metricTeu">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Deviation:</span>
                    <span class="metric-value" id="metricDeviation">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Surge Risk:</span>
                    <span class="metric-value" id="metricRisk">--</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Vessels in Channel:</span>
                    <span class="metric-value" id="metricVessels">--</span>
                </div>
            </div>

            <!-- Quick Action Buttons -->
            <div class="ai-quick-btns">
                <button class="ai-quick-btn" onclick="askAI('What is the expected TEU volume per hour?')">TEU
                    Volume</button>
                <button class="ai-quick-btn" onclick="askAI('What is the current surge risk and why?')">Surge Risk</button>
                <button class="ai-quick-btn" onclick="askAI('When are the next high-risk periods?')">Peak Hours</button>
                <button class="ai-quick-btn"
                    onclick="askAI('What rail dispatch actions do you recommend?')">Recommendations</button>
            </div>

            <!-- Chat Area -->
            <div class="ai-chat-area" id="aiChatArea">
                <div class="ai-message assistant">Ask me about port metrics, surge predictions, or rail recommendations.
                </div>
            </div>

            <!-- Input Area -->
            <div class="ai-input-area">
                <input type="text" class="ai-input" id="aiInput" placeholder="Ask about TEU, surge risk, etc..."
                    onkeypress="if(event.key==='Enter') sendAIMessage()">
                <button class="ai-send-btn" id="aiSendBtn" onclick="sendAIMessage()">Send</button>
            </div>
        </div>
    </div>

    <!-- Forecast Popup Overlay -->
    <div class="popup-overlay" id="forecastOverlay" onclick="closeForecastPopup()"></div>
    <div class="forecast-popup" id="forecastPopup">
        <h3>
            <span>üìÖ 5-Day Weather Forecast</span>
            <button class="close-btn" onclick="closeForecastPopup()">‚úï Close</button>
        </h3>
        <div id="forecastPopupContent">
            <div class="weather-loading">Loading forecast...</div>
        </div>
    </div>

    <!-- Map Controls Panel -->
    <div class="rail-panel panel" id="mapControlsPanel">
        <div class="panel-header">
            <h3>üó∫Ô∏è Map Controls</h3>
            <button class="collapse-btn" onclick="togglePanel('mapControlsPanel')" title="Toggle panel">‚àí</button>
        </div>
        <div class="panel-content" id="mapControlsPanelContent">
            <div class="rail-stats">
                <div><strong>Total Segments:</strong> <span id="railCount">0</span></div>
                <div><strong>Total Miles:</strong> <span id="railMiles">0</span></div>
            </div>
            <div class="rail-toggle">
                <label><input type="checkbox" id="toggleRainOverlay" onchange="toggleRainOverlay()"> üåßÔ∏è Show Rain
                    Overlay</label>
                <label><input type="checkbox" id="toggleRail" checked onchange="toggleRailLayer()"> üöÇ Show Rail
                    Lines</label>
                <label><input type="checkbox" id="toggleNodes" onchange="toggleNodeLayer()"> üöâ Show Rail Nodes</label>
                <label><input type="checkbox" id="toggleUP" checked onchange="filterRailByOwner()"> Union Pacific
                    (UP)</label>
                <label><input type="checkbox" id="toggleBNSF" checked onchange="filterRailByOwner()"> BNSF
                    Railway</label>
                <label><input type="checkbox" id="toggleOther" checked onchange="filterRailByOwner()"> Other
                    Railroads</label>
            </div>
            <div class="rail-stats" style="margin-top:8px;">
                <div><strong>Rail Nodes:</strong> <span id="nodeCount">0</span></div>
                <div><strong>Stations:</strong> <span id="stationCount">0</span></div>
            </div>
            <div class="legend" style="margin-top:8px; padding-top:8px; border-top:1px solid #404040;">
                <div class="legend-item"><span class="legend-line rail-up"></span> Union Pacific</div>
                <div class="legend-item"><span class="legend-line rail-bnsf"></span> BNSF Railway</div>
                <div class="legend-item"><span class="legend-line rail-other"></span> Other (USG, TCT, etc.)</div>
                <div class="legend-item"><span class="legend-node node-junction-color"></span> Junction Node</div>
                <div class="legend-item"><span class="legend-node node-station-color"></span> Passenger Station</div>
            </div>
        </div>
    </div>

    <div class="info-panel panel" id="portInfoPanel">
        <div class="panel-header">
            <h2 style="margin:0;">üö¢ Port of Houston</h2>
            <button class="collapse-btn" onclick="togglePanel('portInfoPanel')" title="Toggle panel">‚àí</button>
        </div>
        <div class="panel-content" id="portInfoPanelContent">

            <p>AIS Ship Tracking</p>

            <div class="ship-count">
                <strong>Vessels Tracked:</strong> <span id="shipCount">0</span>
            </div>

            <div class="controls">
                <button class="btn" id="refreshBtn" onclick="loadAISData()">üîÑ Refresh</button>
                <button class="btn" id="autoRefreshBtn" onclick="toggleAutoRefresh()">‚ñ∂Ô∏è Auto</button>
                <button class="btn danger" onclick="clearShips()">üóëÔ∏è Clear</button>
            </div>

            <div id="status" class="status">Ready to load vessels</div>

            <div class="data-source"
                style="margin-top:10px; padding:8px; background:#1a1a1a; border-radius:4px; font-size:10px; color:#d4a574; border:1px solid #404040;">
                <strong>üì° Data Mode:</strong> <span id="dataMode">Simulated</span><br>
                <span style="color:#a0a0a0;">Ships positioned along actual shipping lanes</span>
            </div>

            <div class="legend">
                <div class="legend-item"><span class="legend-ship"></span> Vessels (AIS)</div>
                <div class="legend-item"><span class="legend-dot terminal"></span> Terminals</div>
                <div class="legend-item"><span class="legend-dot container"></span> Container Facilities</div>
                <div class="legend-item"><span class="legend-dot facility"></span> Other Facilities</div>
                <div class="legend-item" style="margin-top:5px; padding-top:5px; border-top:1px solid #404040;"><span
                        class="legend-line rail-up" style="display:inline-block;"></span> Rail Network</div>
            </div>
        </div>
    </div>

    <!-- Ship Arrival Forecast Panel -->
    <div class="forecast-panel panel" id="forecastPanel">
        <div class="panel-header">
            <h3 style="margin:0;">üìÖ 72-Hour Ship Forecast</h3>
            <button class="collapse-btn" onclick="togglePanel('forecastPanel')" title="Toggle panel">‚àí</button>
        </div>
        <div class="panel-content" id="forecastPanelContent">
            <div id="forecastContent">
                <div style="color:#a0aec0; font-style:italic;">Loading forecast...</div>
            </div>
            <div class="forecast-stats" id="forecastStats"></div>
        </div>
    </div>

    <!-- Ship Tracking Panel -->
    <div class="forecast-panel panel" id="trackerPanel" style="top: 380px;">
        <div class="panel-header">
            <h3 style="margin:0;">üìç Ship Tracker</h3>
            <button class="collapse-btn" onclick="togglePanel('trackerPanel')" title="Toggle panel">‚àí</button>
        </div>
        <div class="panel-content" id="trackerPanelContent">
            <div id="trackerContent">
                <div style="color:#a0aec0; font-style:italic;">Initializing tracker...</div>
            </div>
            <div class="tracker-stats" id="trackerStats"></div>
            <div class="tracker-actions" style="margin-top:8px; display:flex; gap:4px; flex-wrap:wrap;">
                <button class="btn" style="padding:4px 8px; font-size:10px;" onclick="showDockedVessels()">Docked</button>
                <button class="btn" style="padding:4px 8px; font-size:10px;" onclick="showVesselHistory()">History</button>
                <button class="btn" style="padding:4px 8px; font-size:10px;" onclick="exportTrackerData()">Export</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="js/ship-forecasting.js"></script>
    <script src="js/ship-tracker.js"></script>
    <script>
        // Initialize map centered on Port of Houston / Galveston Bay area
        const map = L.map('map', {
            minZoom: 10,
            maxBounds: [
                [29.2, -95.5],  // Southwest corner
                [30.0, -94.5]    // Northeast corner
            ],
            maxBoundsViscosity: 1.0  // Prevent panning outside bounds
        }).setView([29.6, -94.85], 11);

        // Theme state
        let isDarkTheme = true;
        let currentTileLayer = null;

        // Initialize with dark theme
        function initMapTheme() {
            if (isDarkTheme) {
                applyDarkTheme();
            } else {
                applyLightTheme();
            }
        }

        // Apply dark theme
        function applyDarkTheme() {
            // Remove existing tile layer
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }

            // Add OpenStreetMap with dark filter
            currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            });
            currentTileLayer.addTo(map);

            // CSS class will handle the filter automatically

            // Update container background
            const container = document.querySelector('.leaflet-container');
            if (container) {
                container.style.backgroundColor = '#0a0a0a';
            }
            
            // Update body background
            document.body.style.background = '#1a1a1a';
            document.body.style.color = '#e0e0e0';

            // Update toggle button
            const toggle = document.getElementById('themeToggle');
            if (toggle) {
                toggle.classList.remove('light-theme');
                toggle.querySelector('#themeIcon').textContent = 'üåô';
                toggle.querySelector('#themeText').textContent = 'Dark Theme';
            }

            // Apply dark panel styles
            document.body.classList.add('dark-theme');
            document.body.classList.remove('light-theme');
        }

        // Apply light theme
        function applyLightTheme() {
            // Remove existing tile layer
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }

            // Add standard OpenStreetMap
            currentTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            });
            currentTileLayer.addTo(map);

            // CSS class will handle removing the filter automatically

            // Update container background
            const container = document.querySelector('.leaflet-container');
            if (container) {
                container.style.backgroundColor = '#f4f4f4';
            }
            
            // Update body background
            document.body.style.background = '#ffffff';
            document.body.style.color = '#2d3748';

            // Update toggle button
            const toggle = document.getElementById('themeToggle');
            if (toggle) {
                toggle.classList.add('light-theme');
                toggle.querySelector('#themeIcon').textContent = '‚òÄÔ∏è';
                toggle.querySelector('#themeText').textContent = 'Light Theme';
            }

            // Apply light panel styles
            document.body.classList.add('light-theme');
            document.body.classList.remove('dark-theme');
        }

        // Toggle theme
        function toggleTheme() {
            isDarkTheme = !isDarkTheme;
            if (isDarkTheme) {
                applyDarkTheme();
            } else {
                applyLightTheme();
            }
        }

        // Initialize map with dark theme
        initMapTheme();

        // Layer groups
        const facilitiesLayer = L.layerGroup().addTo(map);
        const shipsLayer = L.layerGroup().addTo(map);
        const railLayer = L.layerGroup().addTo(map);
        const nodesLayer = L.layerGroup(); // Not added by default (too many nodes)

        // Rain/precipitation overlay layer
        let rainOverlayLayer = null;

        // Store forecast data for popup
        let storedForecastData = null;

        // Rail data storage
        let railSegments = [];
        let railNodes = [];
        let nodeMap = new Map(); // Map of nodeId -> {lat, lng}

        // Store all vessels for count recalculation on map move/zoom
        let allVessels = [];

        // Auto-refresh state
        let autoRefreshInterval = null;
        let isAutoRefreshing = false;

        // Weather API configuration
        // Get free API key at https://openweathermap.org/api
        const WEATHER_API_KEY = ''; // Add your OpenWeatherMap API key here
        const WEATHER_LAT = 29.6;   // Houston/Galveston area latitude
        const WEATHER_LON = -94.85; // Houston/Galveston area longitude

        // Port facilities data - Houston and Galveston area
        const facilities = [
            { name: "Barbours Cut Container Terminal", lat: 29.7234, lng: -95.0012, type: "terminal", desc: "Major container terminal" },
            { name: "Bayport Container Terminal", lat: 29.6234, lng: -94.9912, type: "terminal", desc: "Modern container facility" },
            { name: "Turning Basin Terminal", lat: 29.7355, lng: -95.2755, type: "terminal", desc: "General cargo terminal" },
            { name: "Care Terminal", lat: 29.7156, lng: -95.0234, type: "container", desc: "Container handling" },
            { name: "Jacintoport Terminal", lat: 29.7456, lng: -95.0834, type: "container", desc: "Break-bulk cargo" },
            { name: "Galena Park Terminal", lat: 29.7356, lng: -95.2155, type: "facility", desc: "Industrial terminal" },
            { name: "Manchester Terminal", lat: 29.7256, lng: -95.2555, type: "facility", desc: "Bulk cargo facility" },
            { name: "Greens Bayou Terminal", lat: 29.7756, lng: -95.1255, type: "facility", desc: "General cargo" },
            { name: "Galveston Wharves", lat: 29.3108, lng: -94.7872, type: "terminal", desc: "Cruise & cargo terminal" },
            { name: "Texas City Terminal", lat: 29.3834, lng: -94.9134, type: "facility", desc: "Petrochemical terminal" }
        ];

        // Color mapping for facilities
        const colors = {
            terminal: '#e53e3e',
            container: '#3182ce',
            facility: '#38a169'
        };

        // Add facility markers
        facilities.forEach(f => {
            const marker = L.circleMarker([f.lat, f.lng], {
                radius: 8,
                fillColor: colors[f.type],
                color: '#fff',
                weight: 2,
                fillOpacity: 0.8
            }).addTo(facilitiesLayer);
            marker.bindPopup(`<strong>${f.name}</strong><br>${f.desc}`);
        });

        // Draw Houston Ship Channel (from Galveston Bay to Turning Basin)
        const channelPath = [
            [29.35, -94.82],      // Galveston Bay entrance
            [29.55, -94.92],
            [29.68, -94.98],      // Morgan's Point area
            [29.7234, -95.0012],  // Barbours Cut
            [29.7355, -95.0555],
            [29.7355, -95.1555],
            [29.7355, -95.2555],
            [29.7355, -95.2955]   // Turning Basin
        ];

        L.polyline(channelPath, {
            color: '#4299e1',
            weight: 4,
            opacity: 0.5,
            dashArray: '10, 10'
        }).addTo(facilitiesLayer).bindPopup('Houston Ship Channel');

        // Create ship icon based on heading
        function createShipIcon(heading, shipType) {
            const color = getShipColor(shipType);
            const rotation = heading || 0;

            return L.divIcon({
                className: 'ship-icon',
                html: `<svg width="24" height="24" viewBox="0 0 24 24" style="transform: rotate(${rotation}deg);">
                    <path d="M12 2 L18 20 L12 16 L6 20 Z" fill="${color}" stroke="#fff" stroke-width="1.5"/>
                </svg>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        // Get ship color based on type
        function getShipColor(shipType) {
            const type = (shipType || '').toLowerCase();
            if (type.includes('tanker') || type.includes('oil')) return '#e53e3e';
            if (type.includes('container')) return '#3182ce';
            if (type.includes('cargo') || type.includes('bulk')) return '#f6ad55';
            if (type.includes('tug')) return '#805ad5';
            return '#718096';
        }

        // Get vessel type class for popup styling
        function getTypeClass(shipType) {
            const type = (shipType || '').toLowerCase();
            if (type.includes('tanker')) return 'type-tanker';
            if (type.includes('container')) return 'type-container';
            if (type.includes('cargo') || type.includes('bulk')) return 'type-cargo';
            return 'type-other';
        }

        // Format speed
        function formatSpeed(speed) {
            if (!speed || speed < 0) return 'N/A';
            return `${speed.toFixed(1)} knots`;
        }

        // Update status display
        function setStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }

        // AISStream WebSocket connection (for real-time data)
        let aisSocket = null;
        const AIS_API_KEY = ''; // Get free key at https://aisstream.io

        // Load AIS data - tries multiple sources
        async function loadAISData() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            setStatus('Loading vessel data...', 'loading');

            // If we have an API key, use real-time WebSocket
            if (AIS_API_KEY) {
                connectToAISStream();
                return;
            }

            try {
                // Bounding box for Houston/Galveston area
                const minLat = 29.2;
                const maxLat = 29.9;
                const minLon = -95.4;
                const maxLon = -94.7;

                // Try ArcGIS Maritime service
                const response = await fetch(
                    `https://services.arcgis.com/LBbVDC0hKPAnLRpO/arcgis/rest/services/AIS_Vessel_Tracks/FeatureServer/0/query?` +
                    `where=1%3D1&geometry=${minLon}%2C${minLat}%2C${maxLon}%2C${maxLat}&geometryType=esriGeometryEnvelope&` +
                    `inSR=4326&spatialRel=esriSpatialRelIntersects&outFields=*&returnGeometry=true&f=json`,
                    { signal: AbortSignal.timeout(8000) }
                );

                if (!response.ok) throw new Error('AIS API unavailable');

                const data = await response.json();

                if (data.features && data.features.length > 0) {
                    // Log first feature to see what fields are available
                    if (data.features.length > 0) {
                        console.log('ArcGIS API Sample Feature:', data.features[0]);
                        console.log('Available Attributes:', Object.keys(data.features[0].attributes || {}));
                    }
                    
                    const vessels = data.features.map(f => {
                        const attrs = f.attributes || {};
                        return {
                            lat: f.geometry.y || f.geometry.points?.[0]?.[1],
                            lng: f.geometry.x || f.geometry.points?.[0]?.[0],
                            name: attrs.VesselName || attrs.VESSEL_NAME || attrs.SHIPNAME || attrs.name || 'Unknown',
                            mmsi: attrs.MMSI || attrs.mmsi || attrs.MMSI_NUMBER || 'Unknown',
                            heading: attrs.Heading || attrs.COG || attrs.HEADING || attrs.heading || 0,
                            speed: attrs.SOG || attrs.Speed || attrs.SPEED || attrs.speed || 0,
                            type: attrs.VesselType || attrs.VESSEL_TYPE || attrs.SHIPTYPE || attrs.type || 'Unknown',
                            destination: attrs.Destination || attrs.DESTINATION || attrs.destination || 'Unknown',
                            flag: attrs.Flag || attrs.FLAG || attrs.COUNTRY || attrs.flag || 'Unknown',
                            length: attrs.Length || attrs.LENGTH || attrs.length || 'Unknown',
                            draft: attrs.Draft || attrs.DRAFT || attrs.draft || 'Unknown'
                        };
                    }).filter(v => v.lat && v.lng);

                    if (vessels.length > 0) {
                        document.getElementById('dataMode').textContent = 'Live (ArcGIS)';
                        if (isDarkTheme) {
                            document.getElementById('dataMode').parentElement.style.background = '#1a2a1a';
                            document.getElementById('dataMode').parentElement.style.borderColor = '#2a4a2a';
                        } else {
                            document.getElementById('dataMode').parentElement.style.background = '#d1fae5';
                            document.getElementById('dataMode').parentElement.style.borderColor = '#86efac';
                        }
                        displayVessels(vessels);
                        refreshBtn.disabled = false;
                        return;
                    }
                }
                throw new Error('No vessels in response');

            } catch (error) {
                console.log('API unavailable, using simulation:', error.message);
                document.getElementById('dataMode').textContent = 'Simulated Demo';
                if (isDarkTheme) {
                    document.getElementById('dataMode').parentElement.style.background = '#2a2a1a';
                    document.getElementById('dataMode').parentElement.style.borderColor = '#4a4a2a';
                } else {
                    document.getElementById('dataMode').parentElement.style.background = '#fffbeb';
                    document.getElementById('dataMode').parentElement.style.borderColor = '#fde68a';
                }
                displayVessels(generateSimulatedVessels());
            }

            refreshBtn.disabled = false;
        }

        // Connect to AISStream.io for real-time data
        function connectToAISStream() {
            if (!AIS_API_KEY) return;

            if (aisSocket) {
                aisSocket.close();
            }

            setStatus('Connecting to AIS stream...', 'loading');

            aisSocket = new WebSocket('wss://stream.aisstream.io/v0/stream');

            aisSocket.onopen = () => {
                // Subscribe to Houston/Galveston area
                const subscribeMsg = {
                    APIKey: AIS_API_KEY,
                    BoundingBoxes: [[[-95.4, 29.2], [-94.7, 29.9]]]
                };
                aisSocket.send(JSON.stringify(subscribeMsg));
                setStatus('Connected to live AIS stream', 'success');
                document.getElementById('dataMode').textContent = 'Live (AISStream)';
                if (isDarkTheme) {
                    document.getElementById('dataMode').parentElement.style.background = '#1a2a1a';
                    document.getElementById('dataMode').parentElement.style.borderColor = '#2a4a2a';
                } else {
                    document.getElementById('dataMode').parentElement.style.background = '#d1fae5';
                    document.getElementById('dataMode').parentElement.style.borderColor = '#86efac';
                }
            };

            const liveVessels = new Map();
            let updateTimeout = null;

            // Function to update display with current vessel data
            const updateDisplay = () => {
                // Cleanup old vessels (not seen in 5 minutes)
                const VESSEL_TIMEOUT = 5 * 60 * 1000;
                const now = Date.now();
                for (const [mmsi, vessel] of liveVessels.entries()) {
                    if (now - (vessel.lastSeen || 0) > VESSEL_TIMEOUT) {
                        liveVessels.delete(mmsi);
                    }
                }
                // Update display with actual vessel count from AIS data
                displayVessels(Array.from(liveVessels.values()));
            };

            aisSocket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.MessageType === 'PositionReport') {
                    const pos = msg.Message.PositionReport;
                    const meta = msg.MetaData;

                    // Log first message to see what fields are available
                    if (liveVessels.size === 0) {
                        console.log('AISStream WebSocket Sample Message:', msg);
                        console.log('PositionReport fields:', Object.keys(pos || {}));
                        console.log('MetaData fields:', Object.keys(meta || {}));
                    }

                    liveVessels.set(meta.MMSI, {
                        mmsi: meta.MMSI || 'Unknown',
                        name: meta.ShipName || meta.shipName || 'Unknown',
                        lat: pos.Latitude,
                        lng: pos.Longitude,
                        heading: pos.TrueHeading || pos.Cog || pos.Heading || 0,
                        speed: pos.Sog || pos.Speed || 0,
                        type: meta.ShipType || meta.shipType || 'Unknown',
                        destination: meta.Destination || meta.destination || 'Unknown',
                        flag: meta.Flag || meta.flag || meta.Country || 'Unknown',
                        length: meta.Length || meta.length || 'Unknown',
                        draft: meta.Draught || meta.Draft || meta.draft || 'Unknown',
                        lastSeen: Date.now()
                    });

                    // Debounced update - update display after a short delay to batch updates
                    if (updateTimeout) clearTimeout(updateTimeout);
                    updateTimeout = setTimeout(updateDisplay, 500);
                }
            };

            // Periodic update to ensure count stays current and cleanup happens
            const periodicUpdate = setInterval(updateDisplay, 5000);

            aisSocket.onerror = (error) => {
                console.error('AIS WebSocket error:', error);
                if (updateTimeout) clearTimeout(updateTimeout);
                if (periodicUpdate) clearInterval(periodicUpdate);
                setStatus('Stream error, using simulation', 'error');
                displayVessels(generateSimulatedVessels());
            };

            aisSocket.onclose = () => {
                if (updateTimeout) clearTimeout(updateTimeout);
                if (periodicUpdate) clearInterval(periodicUpdate);
                setStatus('Stream disconnected', '');
            };

            document.getElementById('refreshBtn').disabled = false;
        }

        // Generate simulated vessels for demo purposes
        // These are realistic positions along the Houston Ship Channel
        function generateSimulatedVessels() {
            // Real vessel names that commonly visit Port of Houston
            const vesselNames = [
                'MSC AURORA', 'MAERSK SEALAND', 'EVER GOLDEN', 'CMA CGM MARCO POLO',
                'COSCO SHIPPING ARIES', 'HAPAG-LLOYD EXPRESS', 'YANG MING UNITY',
                'ONE COLUMBA', 'HYUNDAI BRAVE', 'ZIM SAVANNAH', 'OOCL ATLANTA',
                'PIL PUSAN', 'MEDITERRANEAN STAR', 'ATLANTIC VOYAGER', 'GULF TRADER',
                'HOUSTON EXPRESS', 'TEXAS ENTERPRISE', 'BAYPORT CARRIER', 'CHANNEL RUNNER',
                'GALVESTON BAY', 'LONE STAR TANKER', 'ENERGY FRONTIER', 'PETROCHEMICAL HOUSTON'
            ];

            const vesselTypes = ['Cargo', 'Container Ship', 'Tanker', 'Bulk Carrier', 'Chemical Tanker', 'LNG Tanker', 'Tug'];
            const destinations = ['HOUSTON TX', 'GALVESTON TX', 'TEXAS CITY TX', 'BAYPORT TX', 'BARBOURS CUT TX', 'LA PORTE TX'];
            const flags = ['US', 'PA', 'LR', 'MH', 'SG', 'HK', 'GR', 'MT', 'BS', 'CY', 'NO', 'DK'];

            // Simple hash function to generate deterministic "random" values based on position
            function hashPosition(lat, lng) {
                const str = `${lat.toFixed(4)}_${lng.toFixed(4)}`;
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return Math.abs(hash);
            }

            // Deterministic random function based on seed
            function seededRandom(seed) {
                const x = Math.sin(seed) * 10000;
                return x - Math.floor(x);
            }

            const vessels = [];
            const numVessels = 35; // Fixed number for consistency

            // Define realistic ship positions along the Houston Ship Channel and Galveston Bay
            const shipPositions = [
                // Deep Gulf of Mexico - ships 80-120nm out (48-72 hour ETA)
                { lat: 27.8, lng: -93.5, heading: 315, zone: 'deep-gulf' },
                { lat: 27.9, lng: -93.8, heading: 320, zone: 'deep-gulf' },
                { lat: 28.0, lng: -94.0, heading: 325, zone: 'deep-gulf' },
                { lat: 28.1, lng: -93.6, heading: 318, zone: 'deep-gulf' },
                // Mid Gulf - ships 50-80nm out (24-48 hour ETA)
                { lat: 28.3, lng: -94.0, heading: 330, zone: 'mid-gulf' },
                { lat: 28.4, lng: -94.2, heading: 328, zone: 'mid-gulf' },
                { lat: 28.5, lng: -93.9, heading: 332, zone: 'mid-gulf' },
                { lat: 28.55, lng: -94.1, heading: 335, zone: 'mid-gulf' },
                // Near Gulf - ships 20-50nm out (12-24 hour ETA)
                { lat: 28.7, lng: -94.2, heading: 338, zone: 'near-gulf' },
                { lat: 28.8, lng: -94.3, heading: 340, zone: 'near-gulf' },
                { lat: 28.95, lng: -94.35, heading: 340, zone: 'gulf' },
                { lat: 29.02, lng: -94.42, heading: 335, zone: 'gulf' },
                { lat: 29.08, lng: -94.48, heading: 332, zone: 'gulf' },
                { lat: 29.15, lng: -94.55, heading: 330, zone: 'gulf' },
                { lat: 29.22, lng: -94.62, heading: 328, zone: 'gulf' },
                // Galveston Bay approach - ships entering
                { lat: 29.28, lng: -94.68, heading: 330, zone: 'approach' },
                { lat: 29.32, lng: -94.72, heading: 330, zone: 'approach' },
                { lat: 29.36, lng: -94.76, heading: 325, zone: 'approach' },
                { lat: 29.40, lng: -94.78, heading: 320, zone: 'bay' },
                // Galveston Bay - ships transiting
                { lat: 29.40, lng: -94.78, heading: 320, zone: 'bay' },
                { lat: 29.45, lng: -94.82, heading: 315, zone: 'bay' },
                { lat: 29.50, lng: -94.86, heading: 310, zone: 'bay' },
                { lat: 29.53, lng: -94.88, heading: 305, zone: 'bay' },
                // Entering Houston Ship Channel from Morgan's Point
                { lat: 29.58, lng: -94.91, heading: 300, zone: 'channel' },
                { lat: 29.62, lng: -94.94, heading: 295, zone: 'channel' },
                { lat: 29.66, lng: -94.97, heading: 290, zone: 'channel' },
                { lat: 29.68, lng: -94.98, heading: 290, zone: 'channel' },
                { lat: 29.69, lng: -95.00, heading: 285, zone: 'channel' },
                // Mid channel near Bayport
                { lat: 29.71, lng: -95.02, heading: 280, zone: 'channel' },
                { lat: 29.72, lng: -95.05, heading: 275, zone: 'channel' },
                { lat: 29.72, lng: -95.08, heading: 270, zone: 'channel' },
                // Near Jacintoport
                { lat: 29.73, lng: -95.10, heading: 270, zone: 'channel' },
                { lat: 29.73, lng: -95.12, heading: 268, zone: 'channel' },
                { lat: 29.73, lng: -95.15, heading: 265, zone: 'channel' },
                // Approaching Turning Basin
                { lat: 29.74, lng: -95.18, heading: 265, zone: 'upper' },
                { lat: 29.74, lng: -95.22, heading: 260, zone: 'upper' },
                { lat: 29.74, lng: -95.26, heading: 255, zone: 'upper' },
                // At terminals (stationary/slow)
                { lat: 29.72, lng: -95.00, heading: 45, zone: 'terminal', speed: 0 },
                { lat: 29.62, lng: -94.99, heading: 90, zone: 'terminal', speed: 0 },
                { lat: 29.74, lng: -95.27, heading: 180, zone: 'terminal', speed: 0.5 },
                { lat: 29.31, lng: -94.79, heading: 90, zone: 'terminal', speed: 0 }, // Galveston
            ];

            for (let i = 0; i < Math.min(numVessels, shipPositions.length); i++) {
                const basePos = shipPositions[i];
                // Use base position for deterministic hash (before any offset)
                const seed = hashPosition(basePos.lat, basePos.lng);
                
                // Add small deterministic offset for realism (based on seed)
                const pos = {
                    ...basePos,
                    lat: basePos.lat + (seededRandom(seed) - 0.5) * 0.015,
                    lng: basePos.lng + (seededRandom(seed + 1) - 0.5) * 0.015,
                    heading: basePos.heading + (seededRandom(seed + 2) - 0.5) * 15
                };

                // Speed based on zone (deterministic)
                let speed;
                if (pos.speed !== undefined) {
                    speed = pos.speed;
                } else if (pos.zone === 'terminal') {
                    speed = seededRandom(seed + 3) * 1;
                } else if (pos.zone === 'channel' || pos.zone === 'upper') {
                    speed = 6 + seededRandom(seed + 3) * 6; // 6-12 knots in channel
                } else if (pos.zone === 'bay') {
                    speed = 10 + seededRandom(seed + 3) * 8; // 10-18 knots in bay
                } else {
                    speed = 8 + seededRandom(seed + 3) * 6; // 8-14 knots
                }

                // All metadata is deterministic based on position
                const vesselType = vesselTypes[Math.floor(seededRandom(seed + 4) * vesselTypes.length)];
                const nameIndex = Math.floor(seededRandom(seed + 5) * vesselNames.length);
                const destIndex = Math.floor(seededRandom(seed + 6) * destinations.length);
                const flagIndex = Math.floor(seededRandom(seed + 7) * flags.length);
                const mmsiBase = 300000000 + Math.floor(seededRandom(seed + 8) * 99999999);

                vessels.push({
                    mmsi: mmsiBase,
                    name: vesselNames[nameIndex],
                    lat: pos.lat,
                    lng: pos.lng,
                    heading: pos.heading,
                    speed: speed,
                    type: vesselType,
                    destination: destinations[destIndex],
                    flag: flags[flagIndex],
                    length: vesselType.includes('Container') ? 300 + Math.floor(seededRandom(seed + 9) * 100) :
                        vesselType.includes('Tanker') ? 200 + Math.floor(seededRandom(seed + 9) * 150) :
                            vesselType.includes('Tug') ? 25 + Math.floor(seededRandom(seed + 9) * 15) :
                                100 + Math.floor(seededRandom(seed + 9) * 200),
                    draft: vesselType.includes('Tanker') ? 12 + seededRandom(seed + 10) * 8 : 8 + seededRandom(seed + 10) * 8
                });
            }

            return vessels;
        }

        // Display vessels on map
        function displayVessels(vessels) {
            // Store all vessels for count recalculation
            allVessels = vessels;
            
            shipsLayer.clearLayers();
            
            // Get current map visible bounds for counting
            const bounds = map.getBounds();
            const southWest = bounds.getSouthWest();
            const northEast = bounds.getNorthEast();
            
            let count = 0;

            // Add all vessels to the map (so they appear when you pan)
            vessels.forEach(v => {
                // Handle different API response formats
                const lat = v.lat || v.geometry?.coordinates?.[1] || v.properties?.latitude;
                const lng = v.lng || v.geometry?.coordinates?.[0] || v.properties?.longitude;
                const mmsi = v.mmsi || v.properties?.mmsi || null;
                const name = v.name || v.properties?.name || (mmsi ? `Vessel ${mmsi}` : 'Unknown');
                const heading = v.heading || v.properties?.heading || v.cog || 0;
                const speed = v.speed || v.properties?.sog || 0;
                const type = v.type || v.properties?.shipType || 'Unknown';
                const destination = v.destination || v.properties?.destination || 'Unknown';
                const flag = v.flag || v.properties?.flag || 'Unknown';
                const length = v.length || v.properties?.length || 'Unknown';
                const draft = v.draft || v.properties?.draft || 'Unknown';

                if (!lat || !lng) return;

                // Add marker for all vessels (they'll be visible when you pan to them)
                const icon = createShipIcon(heading, type);
                const marker = L.marker([lat, lng], { icon: icon }).addTo(shipsLayer);

                const typeClass = getTypeClass(type);
                marker.bindPopup(`
                    <div class="vessel-popup">
                        <h3>üö¢ ${name}</h3>
                        <span class="vessel-type ${typeClass}">${type}</span>
                        <div class="detail"><strong>MMSI:</strong> ${mmsi || 'Unknown'}</div>
                        <div class="detail"><strong>Flag:</strong> ${flag}</div>
                        <div class="detail"><strong>Speed:</strong> ${formatSpeed(speed)}</div>
                        <div class="detail"><strong>Heading:</strong> ${heading ? heading.toFixed(0) + '¬∞' : 'Unknown'}</div>
                        <div class="detail"><strong>Destination:</strong> ${destination}</div>
                        <div class="detail"><strong>Length:</strong> ${typeof length === 'number' ? length + ' m' : length}</div>
                        <div class="detail"><strong>Draft:</strong> ${typeof draft === 'number' ? draft.toFixed(1) + ' m' : draft}</div>
                    </div>
                `);

                // Only count vessels within visible map bounds
                if (lat >= southWest.lat && lat <= northEast.lat &&
                    lng >= southWest.lng && lng <= northEast.lng) {
                    count++;
                }
            });

            document.getElementById('shipCount').textContent = count;
            setStatus(`Updated: ${new Date().toLocaleTimeString()}`, 'success');

            // Update ship tracker with AIS data
            if (typeof ShipTracker !== 'undefined') {
                ShipTracker.updateFromAIS(vessels);
                updateTrackerPanel();
            }

            // Update forecast panel with ship data
            updateForecastPanel(vessels);
        }

        // Update vessel count based on visible map bounds
        function updateVesselCount() {
            if (allVessels.length === 0) return;
            
            const bounds = map.getBounds();
            const southWest = bounds.getSouthWest();
            const northEast = bounds.getNorthEast();
            
            let count = 0;
            
            allVessels.forEach(v => {
                const lat = v.lat || v.geometry?.coordinates?.[1] || v.properties?.latitude;
                const lng = v.lng || v.geometry?.coordinates?.[0] || v.properties?.longitude;
                
                if (!lat || !lng) return;
                
                // Check if vessel is within visible map bounds
                if (lat >= southWest.lat && lat <= northEast.lat &&
                    lng >= southWest.lng && lng <= northEast.lng) {
                    count++;
                }
            });
            
            document.getElementById('shipCount').textContent = count;
        }

        // ========== SHIP TRACKER PANEL FUNCTIONS ==========
        
        // Update the tracker panel with current stats
        function updateTrackerPanel() {
            if (typeof ShipTracker === 'undefined') return;
            
            const stats = ShipTracker.getStats();
            const docked = ShipTracker.getDockedVessels();
            
            let html = `
                <div class="forecast-row">
                    <span class="forecast-label">Tracked:</span> <strong>${stats.totalTracked}</strong>
                    <span class="forecast-sep">|</span>
                    <span class="forecast-label">Docked:</span> <strong>${stats.currentlyDocked}</strong>
                    <span class="forecast-sep">|</span>
                    <span class="forecast-label">Unloading:</span> <strong>${stats.unloadingNow}</strong>
                </div>
            `;
            
            if (docked.length > 0) {
                html += `<div style="margin-top:6px; font-size:10px; color:#a0aec0;">Recent docked:</div>`;
                html += `<div style="max-height:80px; overflow-y:auto; font-size:10px;">`;
                docked.slice(0, 5).forEach(v => {
                    const statusIcon = v.status === 'unloading' ? '‚è≥' : '‚öì';
                    html += `<div style="padding:2px 0; border-bottom:1px solid #333;">
                        ${statusIcon} <strong>${v.name}</strong> @ ${v.terminal || 'Unknown'}
                    </div>`;
                });
                html += `</div>`;
            }
            
            document.getElementById('trackerContent').innerHTML = html;
            
            // Update stats
            let statsHtml = `
                <div><strong>Inbound:</strong> ${stats.inbound || 0} | <strong>Departing:</strong> ${stats.departing || 0}</div>
                <div><strong>Departed today:</strong> ${stats.departedToday || 0}</div>
            `;
            if (stats.lastUpdated) {
                const updated = new Date(stats.lastUpdated);
                statsHtml += `<div style="margin-top:4px; font-size:10px; color:#a0aec0;">Updated: ${updated.toLocaleTimeString()}</div>`;
            }
            
            document.getElementById('trackerStats').innerHTML = statsHtml;
        }
        
        // Show modal with docked vessels details
        function showDockedVessels() {
            if (typeof ShipTracker === 'undefined') return;
            
            const docked = ShipTracker.getDockedVessels();
            let content = '<h3>Docked & Unloading Vessels</h3>';
            
            if (docked.length === 0) {
                content += '<p style="color:#a0aec0;">No vessels currently docked.</p>';
            } else {
                content += '<div style="max-height:400px; overflow-y:auto;">';
                docked.forEach(v => {
                    const statusIcon = v.status === 'unloading' ? '‚è≥ Unloading' : '‚öì Docked';
                    const dockedTime = v.dockedAt ? new Date(v.dockedAt).toLocaleString() : 'Unknown';
                    content += `
                        <div style="padding:8px; margin:4px 0; background:#1a1a2e; border-radius:4px;">
                            <div><strong>üö¢ ${v.name}</strong></div>
                            <div style="font-size:11px; color:#a0aec0;">
                                ${statusIcon} @ ${v.terminal || 'Unknown Terminal'}<br>
                                Type: ${v.type} | Flag: ${v.flag}<br>
                                Docked: ${dockedTime}<br>
                                MMSI: ${v.mmsi}
                            </div>
                        </div>
                    `;
                });
                content += '</div>';
            }
            
            showModal(content);
        }
        
        // Show vessel history
        function showVesselHistory() {
            if (typeof ShipTracker === 'undefined') return;
            
            const history = ShipTracker.getRecentHistory(30);
            let content = '<h3>Recent Vessel Activity</h3>';
            
            if (history.length === 0) {
                content += '<p style="color:#a0aec0;">No activity recorded yet.</p>';
            } else {
                content += '<div style="max-height:400px; overflow-y:auto;">';
                history.forEach(h => {
                    const time = new Date(h.timestamp).toLocaleString();
                    const statusEmoji = {
                        'docked': '‚öì',
                        'unloading': '‚è≥',
                        'departing': 'üöÄ',
                        'approaching': '‚û°Ô∏è',
                        'inbound': 'üìç'
                    };
                    content += `
                        <div style="padding:6px; margin:2px 0; background:#1a1a2e; border-radius:4px; font-size:11px;">
                            <strong>${h.name}</strong>: ${h.fromStatus} ‚Üí ${statusEmoji[h.toStatus] || ''} ${h.toStatus}
                            ${h.terminal ? `@ ${h.terminal}` : ''}
                            <div style="color:#718096; font-size:10px;">${time}</div>
                        </div>
                    `;
                });
                content += '</div>';
            }
            
            showModal(content);
        }
        
        // Export tracker data
        function exportTrackerData() {
            if (typeof ShipTracker === 'undefined') return;
            ShipTracker.exportData();
            setStatus('Ship tracking data exported', 'success');
        }
        
        // Simple modal function
        function showModal(content) {
            // Remove existing modal if any
            const existing = document.getElementById('trackerModal');
            if (existing) existing.remove();
            
            const modal = document.createElement('div');
            modal.id = 'trackerModal';
            modal.style.cssText = `
                position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                background: #16213e; border: 1px solid #4a5568; border-radius: 8px;
                padding: 20px; max-width: 500px; max-height: 80vh; overflow-y: auto;
                z-index: 10000; box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            `;
            modal.innerHTML = content + `
                <button onclick="document.getElementById('trackerModal').remove()" 
                    style="margin-top:12px; padding:8px 16px; background:#4a5568; color:white; border:none; border-radius:4px; cursor:pointer;">
                    Close
                </button>
            `;
            document.body.appendChild(modal);
        }

        // Update the 72-hour forecast panel
        function updateForecastPanel(vessels) {
            if (!vessels || vessels.length === 0) {
                document.getElementById('forecastContent').innerHTML =
                    '<div style="color:#a0aec0; font-style:italic;">No vessels to forecast</div>';
                return;
            }

            // Normalize vessel data for forecasting
            const normalizedVessels = vessels.map(v => ({
                name: v.name || v.properties?.name || `Vessel ${v.mmsi}`,
                lat: v.lat || v.geometry?.coordinates?.[1] || v.properties?.latitude,
                lon: v.lng || v.geometry?.coordinates?.[0] || v.properties?.longitude,
                speed: v.speed || v.properties?.sog || 10
            })).filter(v => v.lat && v.lon);

            // Get forecast from ShipForecasting module
            const summary = ShipForecasting.getSummary(normalizedVessels);
            const forecast = summary.forecast;

            // Build forecast HTML - simple inline format
            const w24 = forecast.windows["0-24h"];
            const w48 = forecast.windows["24-48h"];
            const w72 = forecast.windows["48-72h"];

            let html = `
                <div class="forecast-row">
                    <span class="forecast-label">0-24h:</span> <strong>${w24.count}</strong> ships
                    <span class="forecast-sep">|</span>
                    <span class="forecast-label">24-48h:</span> <strong>${w48.count}</strong> ships
                    <span class="forecast-sep">|</span>
                    <span class="forecast-label">48-72h:</span> <strong>${w72.count}</strong> ships
                </div>
                <div class="forecast-summary">
                    Total: <strong>${w24.count + w48.count + w72.count}</strong> ships in 72h window
                </div>
            `;

            document.getElementById('forecastContent').innerHTML = html;

            // Update stats
            let statsHtml = `
                <div><strong>Avg arrival gap:</strong> ${summary.avgArrivalGap}</div>
                <div><strong>Est. arrivals/day:</strong> ${summary.arrivalsPerDay}</div>
            `;
            if (summary.closestShips) {
                statsHtml += `<div><strong>Closest ships:</strong> ${summary.closestShips.distance} nm apart</div>`;
            }
            statsHtml += `<div style="margin-top:4px; font-size:10px; color:#a0aec0;">Updated: ${forecast.generatedAt}</div>`;

            document.getElementById('forecastStats').innerHTML = statsHtml;
        }

        // Clear ships from map
        function clearShips() {
            shipsLayer.clearLayers();
            document.getElementById('shipCount').textContent = '0';
            setStatus('Vessels cleared', '');
        }

        // Toggle auto-refresh
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');

            if (isAutoRefreshing) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                isAutoRefreshing = false;
                btn.textContent = '‚ñ∂Ô∏è Auto';
                setStatus('Auto-refresh stopped', '');
            } else {
                loadAISData();
                autoRefreshInterval = setInterval(loadAISData, 60000); // Refresh every 60 seconds
                isAutoRefreshing = true;
                btn.textContent = '‚è∏Ô∏è Auto';
                setStatus('Auto-refresh enabled (60s)', 'success');
            }
        }

        // ========== RAIL NETWORK DATA & VISUALIZATION ==========
        // Rail owner colors
        const railColors = {
            'UP': '#eab308',      // Yellow for Union Pacific
            'BNSF': '#f97316',    // Orange for BNSF
            'TCT': '#6366f1',     // Indigo for Texas City Terminal
            'USG': '#6b7280',     // Gray for US Government
            'BRG': '#10b981',     // Emerald
            'AWRR': '#8b5cf6',    // Violet
            'FWWR': '#ec4899',    // Pink
            'default': '#6b7280'  // Gray default
        };

        // Get owner badge class
        function getOwnerClass(owner) {
            if (owner === 'UP') return 'owner-up';
            if (owner === 'BNSF') return 'owner-bnsf';
            return 'owner-other';
        }

        // Draw rail network dynamically from CSV data
        async function drawRailNetwork() {
            railLayer.clearLayers();
            railSegments = [];

            // Ensure nodes are loaded first
            if (nodeMap.size === 0) {
                await loadRailNodes();
            }

            // Load rail lines from CSV
            const railLines = await loadRailLines();

            if (railLines.length === 0) {
                console.warn('No rail lines loaded');
                document.getElementById('railCount').textContent = '0';
                document.getElementById('railMiles').textContent = '0';
                return;
            }

            const showUP = document.getElementById('toggleUP').checked;
            const showBNSF = document.getElementById('toggleBNSF').checked;
            const showOther = document.getElementById('toggleOther').checked;

            let totalMiles = 0;
            let segmentCount = 0;

            railLines.forEach(rail => {
                // Filter by owner
                if (rail.owner === 'UP' && !showUP) return;
                if (rail.owner === 'BNSF' && !showBNSF) return;
                if (!['UP', 'BNSF'].includes(rail.owner) && !showOther) return;

                const color = railColors[rail.owner] || railColors['default'];
                const weight = rail.tracks > 1 ? 4 : 3;

                const line = L.polyline(rail.coords, {
                    color: color,
                    weight: weight,
                    opacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(railLayer);

                // Popup with rail info
                line.bindPopup(`
                    <div class="rail-popup">
                        <span class="owner-badge ${getOwnerClass(rail.owner)}">${rail.owner}</span>
                        <h4>üõ§Ô∏è ${rail.subdiv || 'Rail Segment'}</h4>
                        <div class="detail"><strong>Owner:</strong> ${getOwnerFullName(rail.owner)}</div>
                        <div class="detail"><strong>Miles:</strong> ${rail.miles.toFixed(2)}</div>
                        <div class="detail"><strong>Tracks:</strong> ${rail.tracks}</div>
                    </div>
                `);

                railSegments.push({ line, data: rail });
                totalMiles += rail.miles;
                segmentCount++;
            });

            // Update stats
            document.getElementById('railCount').textContent = segmentCount;
            document.getElementById('railMiles').textContent = totalMiles.toFixed(1);
        }

        // Get full railroad name
        function getOwnerFullName(code) {
            const names = {
                'UP': 'Union Pacific Railroad',
                'BNSF': 'BNSF Railway',
                'TCT': 'Texas City Terminal Railway',
                'USG': 'US Government',
                'BRG': 'Brownsville & Rio Grande',
                'AWRR': 'Austin Western Railroad',
                'FWWR': 'Fort Worth & Western Railroad'
            };
            return names[code] || code;
        }

        // Toggle rail layer visibility
        async function toggleRailLayer() {
            const show = document.getElementById('toggleRail').checked;
            if (show) {
                map.addLayer(railLayer);
                await drawRailNetwork();
            } else {
                map.removeLayer(railLayer);
            }
        }

        // Filter rail by owner
        async function filterRailByOwner() {
            await drawRailNetwork();
        }

        // ========== RAIL NODES VISUALIZATION ==========

        // Load rail nodes from CSV file and build node map
        async function loadRailNodes() {
            try {
                const response = await fetch('data/railroad-nodes.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');

                // Skip header
                railNodes = [];
                nodeMap.clear();
                let stationCount = 0;

                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 13) continue;

                    const x = parseFloat(cols[11]); // longitude
                    const y = parseFloat(cols[12]); // latitude

                    // Filter to Houston/Galveston area
                    if (x < -95.5 || x > -94.5 || y < 29.2 || y > 30.0) continue;

                    const nodeId = cols[1]; // FRANODEID
                    const node = {
                        objectId: cols[0],
                        fraNodeId: nodeId,
                        state: cols[3],
                        countyFips: cols[5],
                        stCountyFips: cols[6],
                        fraDistrict: cols[7],
                        passenger: cols[8],
                        stationName: cols[9],
                        boundary: parseInt(cols[10]) || 0,
                        lng: x,
                        lat: y
                    };

                    railNodes.push(node);
                    // Store in map for quick lookup by node ID
                    if (nodeId) {
                        nodeMap.set(nodeId, { lat: y, lng: x });
                    }

                    if (node.stationName) stationCount++;
                }

                console.log(`Loaded ${railNodes.length} rail nodes, ${stationCount} stations`);
                document.getElementById('nodeCount').textContent = railNodes.length.toLocaleString();
                document.getElementById('stationCount').textContent = stationCount;

                return railNodes;
            } catch (error) {
                console.error('Error loading rail nodes:', error);
                // Show user-friendly error feedback
                document.getElementById('nodeCount').textContent = 'Error';
                document.getElementById('stationCount').textContent = 'Error';
                return [];
            }
        }

        // Simple CSV parser that handles quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }

        // Load rail lines from CSV file
        async function loadRailLines() {
            try {
                const response = await fetch('data/railroad-lines.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');

                if (lines.length < 2) return [];

                const railLines = [];
                const header = parseCSVLine(lines[0]);

                // Find column indices
                const getColIndex = (name) => {
                    const idx = header.findIndex(h => h.trim() === name);
                    return idx >= 0 ? idx : -1;
                };

                const fromNodeIdx = getColIndex('FRFRANODE');
                const toNodeIdx = getColIndex('TOFRANODE');
                const ownerIdx = getColIndex('RROWNER1');
                const subdivIdx = getColIndex('SUBDIV');
                const tracksIdx = getColIndex('TRACKS');
                const milesIdx = getColIndex('MILES');

                if (fromNodeIdx < 0 || toNodeIdx < 0) {
                    console.error('Required columns not found in CSV');
                    return [];
                }

                // Houston/Galveston area bounds
                const minLat = 29.2;
                const maxLat = 30.0;
                const minLng = -95.5;
                const maxLng = -94.5;

                for (let i = 1; i < lines.length; i++) {
                    const cols = parseCSVLine(lines[i]);
                    if (cols.length < Math.max(fromNodeIdx, toNodeIdx, ownerIdx) + 1) continue;

                    const fromNodeId = cols[fromNodeIdx]?.trim();
                    const toNodeId = cols[toNodeIdx]?.trim();
                    const owner = (ownerIdx >= 0 ? cols[ownerIdx]?.trim() : '') || '';
                    const subdiv = (subdivIdx >= 0 ? cols[subdivIdx]?.trim() : '') || '';
                    const tracks = (tracksIdx >= 0 ? parseInt(cols[tracksIdx]) : 1) || 1;
                    const miles = (milesIdx >= 0 ? parseFloat(cols[milesIdx]) : 0) || 0;

                    if (!fromNodeId || !toNodeId) continue;

                    // Get coordinates from node map
                    const fromNode = nodeMap.get(fromNodeId);
                    const toNode = nodeMap.get(toNodeId);

                    if (!fromNode || !toNode) continue;

                    // Filter to Houston/Galveston area
                    if (fromNode.lat < minLat || fromNode.lat > maxLat ||
                        fromNode.lng < minLng || fromNode.lng > maxLng ||
                        toNode.lat < minLat || toNode.lat > maxLat ||
                        toNode.lng < minLng || toNode.lng > maxLng) {
                        continue;
                    }

                    railLines.push({
                        fromNodeId: fromNodeId,
                        toNodeId: toNodeId,
                        owner: owner,
                        subdiv: subdiv,
                        tracks: tracks,
                        miles: miles,
                        coords: [[fromNode.lat, fromNode.lng], [toNode.lat, toNode.lng]]
                    });
                }

                console.log(`Loaded ${railLines.length} rail line segments`);
                return railLines;
            } catch (error) {
                console.error('Error loading rail lines:', error);
                return [];
            }
        }

        // Draw rail nodes on map
        function drawRailNodes() {
            nodesLayer.clearLayers();

            // Get current zoom level to adjust visibility
            const zoom = map.getZoom();

            // Only show nodes when zoomed in enough (too many otherwise)
            if (zoom < 11) {
                // At low zoom, just show stations
                railNodes.filter(n => n.stationName).forEach(node => {
                    addNodeMarker(node, true);
                });
            } else if (zoom < 13) {
                // Medium zoom: show stations + sample of junctions
                railNodes.forEach((node, i) => {
                    if (node.stationName || node.boundary > 0 || i % 10 === 0) {
                        addNodeMarker(node, node.stationName);
                    }
                });
            } else {
                // High zoom: show all nodes
                railNodes.forEach(node => {
                    addNodeMarker(node, node.stationName);
                });
            }
        }

        // Add a single node marker
        function addNodeMarker(node, isStation) {
            let className, radius, color;

            if (node.stationName) {
                className = 'node-station';
                radius = 8;
                color = '#dc2626';
            } else if (node.boundary > 0) {
                className = 'node-boundary';
                radius = 5;
                color = '#0891b2';
            } else {
                className = 'node-marker';
                radius = 4;
                color = '#7c3aed';
            }

            const marker = L.circleMarker([node.lat, node.lng], {
                radius: radius,
                fillColor: color,
                color: '#fff',
                weight: 1.5,
                fillOpacity: 0.8,
                className: className
            }).addTo(nodesLayer);

            // Create popup content
            let nodeType = 'Junction';
            let badgeClass = 'badge-junction';
            if (node.stationName) {
                nodeType = 'Passenger Station';
                badgeClass = 'badge-station';
            } else if (node.boundary > 0) {
                nodeType = 'Boundary Point';
                badgeClass = 'badge-boundary';
            }

            marker.bindPopup(`
                <div class="node-popup">
                    <span class="node-type-badge ${badgeClass}">${nodeType}</span>
                    <h4>${node.stationName || 'Rail Junction'}</h4>
                    <div class="detail"><strong>Node ID:</strong> ${node.fraNodeId}</div>
                    <div class="detail"><strong>County FIPS:</strong> ${node.stCountyFips}</div>
                    <div class="detail"><strong>FRA District:</strong> ${node.fraDistrict}</div>
                    <div class="detail"><strong>Coords:</strong> ${node.lat.toFixed(4)}, ${node.lng.toFixed(4)}</div>
                    ${node.passenger ? `<div class="detail"><strong>Service:</strong> ${node.passenger}</div>` : ''}
                </div>
            `);
        }

        // Toggle node layer visibility
        function toggleNodeLayer() {
            const checkbox = document.getElementById('toggleNodes');
            const show = checkbox.checked;

            if (show) {
                // Show nodes
                if (railNodes.length === 0) {
                    loadRailNodes().then(() => {
                        drawRailNodes();
                        if (!map.hasLayer(nodesLayer)) {
                            map.addLayer(nodesLayer);
                        }
                    });
                } else {
                    drawRailNodes();
                    if (!map.hasLayer(nodesLayer)) {
                        map.addLayer(nodesLayer);
                    }
                }
            } else {
                // Hide nodes - remove layer from map
                nodesLayer.clearLayers();
                map.removeLayer(nodesLayer);
            }
        }

        // Redraw nodes on zoom change
        map.on('zoomend', function () {
            const checkbox = document.getElementById('toggleNodes');
            if (checkbox && checkbox.checked && map.hasLayer(nodesLayer)) {
                drawRailNodes();
            }
            // Update vessel count when zoom changes
            updateVesselCount();
        });

        // Update vessel count when map is panned
        map.on('moveend', function () {
            updateVesselCount();
        });

        // ========== WEATHER API INTEGRATION ==========

        // Get weather icon emoji based on condition code
        function getWeatherIcon(code, isDay = true) {
            // OpenWeatherMap weather condition codes
            if (code >= 200 && code < 300) return '‚õàÔ∏è'; // Thunderstorm
            if (code >= 300 && code < 400) return 'üåßÔ∏è'; // Drizzle
            if (code >= 500 && code < 600) return 'üåßÔ∏è'; // Rain
            if (code >= 600 && code < 700) return '‚ùÑÔ∏è'; // Snow
            if (code >= 700 && code < 800) return 'üå´Ô∏è'; // Atmosphere (fog, mist, etc.)
            if (code === 800) return isDay ? '‚òÄÔ∏è' : 'üåô'; // Clear
            if (code === 801) return isDay ? 'üå§Ô∏è' : '‚òÅÔ∏è'; // Few clouds
            if (code === 802) return '‚õÖ'; // Scattered clouds
            if (code === 803 || code === 804) return '‚òÅÔ∏è'; // Broken/Overcast clouds
            return 'üå§Ô∏è';
        }

        // Format temperature
        function formatTemp(kelvin) {
            const celsius = kelvin - 273.15;
            const fahrenheit = (celsius * 9 / 5) + 32;
            return {
                f: Math.round(fahrenheit),
                c: Math.round(celsius)
            };
        }

        // Format wind speed
        function formatWindSpeed(ms) {
            const mph = ms * 2.237;
            return Math.round(mph);
        }

        // Get day name
        function getDayName(date) {
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            return days[date.getDay()];
        }

        // Load weather data
        async function loadWeatherData() {
            const weatherContent = document.getElementById('weatherContent');

            // If no API key, show demo data
            if (!WEATHER_API_KEY) {
                weatherContent.innerHTML = `
                    <div class="weather-current">
                        <div class="weather-icon">üå§Ô∏è</div>
                        <div class="temp">78¬∞F</div>
                        <div class="description">Partly Cloudy</div>
                        <div class="details">
                            <span>üí® Wind: 12 mph</span>
                            <span>üíß Humidity: 65%</span>
                        </div>
                        <div class="details">
                            <span>üëÅÔ∏è Visibility: 10 mi</span>
                            <span>üå°Ô∏è Feels: 80¬∞F</span>
                        </div>
                    </div>
                    <div style="margin-top:8px; padding:8px; background:#2a2a1a; border-radius:4px; font-size:10px; color:#d4a574; border:1px solid #4a4a2a;">
                        <strong>‚ö†Ô∏è Demo Mode:</strong> Add OpenWeatherMap API key for live data
                    </div>
                `;

                // Store demo forecast data for popup (temps in Kelvin for formatTemp function)
                // Convert Fahrenheit to Kelvin: K = (F - 32) * 5/9 + 273.15
                const fToK = (f) => (f - 32) * 5 / 9 + 273.15;
                const demoForecastDays = [
                    { date: new Date(), temps: [fToK(78), fToK(65)], conditions: [{ id: 801, description: 'partly cloudy', humidity: 65 }] },
                    { date: new Date(Date.now() + 86400000), temps: [fToK(82), fToK(68)], conditions: [{ id: 800, description: 'clear sky', humidity: 55 }] },
                    { date: new Date(Date.now() + 2 * 86400000), temps: [fToK(79), fToK(66)], conditions: [{ id: 802, description: 'scattered clouds', humidity: 60 }] },
                    { date: new Date(Date.now() + 3 * 86400000), temps: [fToK(75), fToK(64)], conditions: [{ id: 500, description: 'light rain', humidity: 80 }] },
                    { date: new Date(Date.now() + 4 * 86400000), temps: [fToK(81), fToK(67)], conditions: [{ id: 800, description: 'clear sky', humidity: 50 }] }
                ];
                storedForecastData = {
                    dailyForecast: {},
                    forecastDays: demoForecastDays
                };

                return;
            }

            weatherContent.innerHTML = '<div class="weather-loading">Loading weather data...</div>';

            try {
                // Fetch current weather and forecast
                const currentUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${WEATHER_LAT}&lon=${WEATHER_LON}&appid=${WEATHER_API_KEY}`;
                const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${WEATHER_LAT}&lon=${WEATHER_LON}&appid=${WEATHER_API_KEY}`;

                const [currentResponse, forecastResponse] = await Promise.all([
                    fetch(currentUrl),
                    fetch(forecastUrl)
                ]);

                if (!currentResponse.ok || !forecastResponse.ok) {
                    throw new Error('Weather API error');
                }

                const currentData = await currentResponse.json();
                const forecastData = await forecastResponse.json();

                // Format current weather
                const temp = formatTemp(currentData.main.temp);
                const feelsLike = formatTemp(currentData.main.feels_like);
                const windSpeed = formatWindSpeed(currentData.wind.speed);
                const isDay = currentData.dt > currentData.sys.sunrise && currentData.dt < currentData.sys.sunset;
                const icon = getWeatherIcon(currentData.weather[0].id, isDay);

                // Build current weather HTML
                let currentHtml = `
                    <div class="weather-current">
                        <div class="weather-icon">${icon}</div>
                        <div class="temp">${temp.f}¬∞F</div>
                        <div class="description">${currentData.weather[0].description}</div>
                        <div class="details">
                            <span>üí® Wind: ${windSpeed} mph ${currentData.wind.deg ? `(${currentData.wind.deg}¬∞)` : ''}</span>
                            <span>üíß Humidity: ${currentData.main.humidity}%</span>
                        </div>
                        <div class="details">
                            <span>üëÅÔ∏è Visibility: ${currentData.visibility ? (currentData.visibility / 1609.34).toFixed(1) : 'N/A'} mi</span>
                            <span>üå°Ô∏è Feels: ${feelsLike.f}¬∞F</span>
                        </div>
                        <div class="details" style="margin-top:4px;">
                            <span>üìä Pressure: ${currentData.main.pressure} hPa</span>
                            <span>‚òÅÔ∏è Clouds: ${currentData.clouds.all}%</span>
                        </div>
                    </div>
                `;

                // Group forecast by day and get max/min temps for popup
                const dailyForecast = {};
                forecastData.list.forEach(item => {
                    const date = new Date(item.dt * 1000);
                    const dayKey = date.toDateString();

                    if (!dailyForecast[dayKey]) {
                        dailyForecast[dayKey] = {
                            date: date,
                            temps: [],
                            conditions: [],
                            icons: []
                        };
                    }

                    dailyForecast[dayKey].temps.push(item.main.temp_max, item.main.temp_min);
                    dailyForecast[dayKey].conditions.push(item.weather[0]);
                    dailyForecast[dayKey].icons.push(getWeatherIcon(item.weather[0].id, true));
                });

                // Only show current weather in panel
                weatherContent.innerHTML = currentHtml;

                // Store forecast data for popup
                storedForecastData = {
                    dailyForecast: dailyForecast,
                    forecastDays: Object.values(dailyForecast).slice(0, 5)
                };

            } catch (error) {
                console.error('Weather API error:', error);
                weatherContent.innerHTML = `
                    <div class="weather-error">
                        ‚ö†Ô∏è Unable to load weather data<br>
                        <small>Check API key or network connection</small>
                    </div>
                `;
            }
        }

        // Toggle rain/precipitation overlay on map
        function toggleRainOverlay() {
            const checkbox = document.getElementById('toggleRainOverlay');
            const show = checkbox.checked;

            if (show) {
                // Remove existing overlay if any
                if (rainOverlayLayer && map.hasLayer(rainOverlayLayer)) {
                    map.removeLayer(rainOverlayLayer);
                    rainOverlayLayer = null;
                }

                // Create rain overlay layer
                // Use transparent PNG for error tiles to avoid green sections
                const transparentTile = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
                
                if (WEATHER_API_KEY) {
                    // Use OpenWeatherMap precipitation layer (best quality, requires API key)
                    rainOverlayLayer = L.tileLayer(`https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${WEATHER_API_KEY}`, {
                        attribution: 'Rain data ¬© OpenWeatherMap',
                        opacity: 0.65,
                        maxZoom: 19,
                        errorTileUrl: transparentTile,
                        tileSize: 256,
                        zoomOffset: 0
                    });
                } else {
                    // Use RainViewer API (free, no key required)
                    // Get latest available timestamp (rounded to nearest 10 minutes)
                    const now = Math.floor(Date.now() / 1000);
                    const roundedTime = Math.floor(now / 600) * 600; // Round to nearest 10 minutes

                    rainOverlayLayer = L.tileLayer(`https://tilecache.rainviewer.com/v2/radar/${roundedTime}/256/{z}/{x}/{y}/2/1_1.png`, {
                        attribution: 'Rain data ¬© RainViewer.com',
                        opacity: 0.7,
                        maxZoom: 19,
                        errorTileUrl: transparentTile,
                        tileSize: 256,
                        zoomOffset: 0,
                        crossOrigin: true
                    });
                }
                
                // Handle tile errors - hide failed tiles instead of showing green
                rainOverlayLayer.on('tileerror', function(error, tile) {
                    if (tile && tile.el) {
                        tile.el.style.display = 'none';
                    }
                });

                // Add overlay to map
                rainOverlayLayer.addTo(map);
            } else {
                // Remove overlay from map
                if (rainOverlayLayer && map.hasLayer(rainOverlayLayer)) {
                    map.removeLayer(rainOverlayLayer);
                }
            }
        }

        // Show forecast popup
        function showForecastPopup() {
            const popup = document.getElementById('forecastPopup');
            const overlay = document.getElementById('forecastOverlay');
            const content = document.getElementById('forecastPopupContent');

            // Generate forecast content
            if (storedForecastData && storedForecastData.forecastDays) {
                let popupHtml = '<div class="forecast-popup-grid">';

                storedForecastData.forecastDays.forEach((day, index) => {
                    const maxTemp = formatTemp(Math.max(...day.temps));
                    const minTemp = formatTemp(Math.min(...day.temps));
                    const mainCondition = day.conditions[Math.floor(day.conditions.length / 2)];
                    const mainIcon = getWeatherIcon(mainCondition.id, true);

                    let dayLabel;
                    if (index === 0) {
                        dayLabel = 'Today';
                    } else if (index === 1) {
                        dayLabel = 'Tomorrow';
                    } else {
                        dayLabel = getDayName(day.date);
                    }

                    // Get additional details from forecast
                    const avgHumidity = day.conditions.length > 0 ?
                        (day.conditions.reduce((sum, c) => sum + (c.humidity || 0), 0) / day.conditions.length).toFixed(0) : 'N/A';

                    popupHtml += `
                        <div class="forecast-popup-item">
                            <div class="day">${dayLabel}</div>
                            <div class="icon">${mainIcon}</div>
                            <div class="temp">${maxTemp.f}¬∞ / ${minTemp.f}¬∞</div>
                            <div class="desc">${mainCondition.description}</div>
                            <div class="details">
                                ${day.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                            </div>
                        </div>
                    `;
                });

                popupHtml += '</div>';
                content.innerHTML = popupHtml;
            } else {
                // No forecast data available - try to load it
                content.innerHTML = '<div class="weather-loading">Loading forecast data...<br><small>Please wait or refresh weather data first</small></div>';
                // Try to load weather data if not already loaded
                if (!storedForecastData) {
                    loadWeatherData().then(() => {
                        // Retry showing popup after data loads
                        setTimeout(showForecastPopup, 500);
                    });
                }
            }

            // Show popup and overlay
            popup.classList.add('show');
            overlay.classList.add('show');
        }

        // Close forecast popup
        function closeForecastPopup() {
            const popup = document.getElementById('forecastPopup');
            const overlay = document.getElementById('forecastOverlay');
            popup.classList.remove('show');
            overlay.classList.remove('show');
        }

        // Initialize rail network (async - loads from CSV)
        loadRailNodes().then(() => {
            drawRailNetwork();
        });

        // Load initial data
        loadAISData();

        // ========== AI ANALYTICS INTEGRATION ==========

        // API Configuration - adjust if running on different port
        const API_BASE_URL = 'http://localhost:5000';

        // Check API status and update indicator
        async function checkAPIStatus() {
            const statusDot = document.getElementById('aiStatusDot');
            try {
                const response = await fetch(`${API_BASE_URL}/api/health`, {
                    signal: AbortSignal.timeout(3000)
                });
                if (response.ok) {
                    statusDot.className = 'status-dot';
                    return true;
                }
            } catch (e) {
                console.log('API not available:', e.message);
            }
            statusDot.className = 'status-dot offline';
            return false;
        }

        // Refresh metrics from API
        async function refreshMetrics() {
            const statusDot = document.getElementById('aiStatusDot');
            statusDot.className = 'status-dot loading';

            try {
                const response = await fetch(`${API_BASE_URL}/api/metrics`);
                if (!response.ok) throw new Error('API error');

                const metrics = await response.json();

                // Update display
                document.getElementById('metricTeu').textContent = `${metrics.current_teu_per_hour} TEU`;
                document.getElementById('metricDeviation').textContent = `${metrics.percent_deviation > 0 ? '+' : ''}${metrics.percent_deviation}%`;

                const riskEl = document.getElementById('metricRisk');
                riskEl.textContent = metrics.surge_risk;
                riskEl.className = `metric-value risk-${metrics.surge_risk.toLowerCase()}`;

                document.getElementById('metricVessels').textContent = metrics.vessels_in_channel;

                statusDot.className = 'status-dot';
            } catch (e) {
                console.error('Failed to fetch metrics:', e);
                statusDot.className = 'status-dot offline';

                // Show demo data if API unavailable
                document.getElementById('metricTeu').textContent = '~175 TEU';
                document.getElementById('metricDeviation').textContent = '+20%';
                document.getElementById('metricRisk').textContent = 'MEDIUM';
                document.getElementById('metricRisk').className = 'metric-value risk-medium';
                document.getElementById('metricVessels').textContent = '~25';
            }
        }

        // Add message to chat area
        function addChatMessage(content, type = 'assistant') {
            const chatArea = document.getElementById('aiChatArea');
            const msg = document.createElement('div');
            msg.className = `ai-message ${type}`;
            msg.textContent = content;
            chatArea.appendChild(msg);
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // Send message to AI
        async function sendAIMessage() {
            const input = document.getElementById('aiInput');
            const sendBtn = document.getElementById('aiSendBtn');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage(message, 'user');
            input.value = '';
            sendBtn.disabled = true;

            try {
                const response = await fetch(`${API_BASE_URL}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message }),
                    signal: AbortSignal.timeout(60000)
                });

                if (!response.ok) throw new Error('API error');

                const data = await response.json();
                addChatMessage(data.response, 'assistant');

                // Update metrics if included
                if (data.metrics) {
                    document.getElementById('metricTeu').textContent = `${data.metrics.current_teu_per_hour} TEU`;
                    document.getElementById('metricDeviation').textContent = `${data.metrics.percent_deviation > 0 ? '+' : ''}${data.metrics.percent_deviation}%`;
                    const riskEl = document.getElementById('metricRisk');
                    riskEl.textContent = data.metrics.surge_risk;
                    riskEl.className = `metric-value risk-${data.metrics.surge_risk.toLowerCase()}`;
                }
            } catch (e) {
                console.error('AI chat error:', e);
                addChatMessage('Could not connect to AI. Make sure the API server is running (python api_server.py)', 'error');
            }

            sendBtn.disabled = false;
        }

        // Quick ask button handler
        function askAI(question) {
            document.getElementById('aiInput').value = question;
            sendAIMessage();
        }

        // Initialize AI panel
        checkAPIStatus();
        refreshMetrics();

        // Refresh metrics every 60 seconds
        setInterval(refreshMetrics, 60000);

        // Toggle panel collapse/expand
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const content = document.getElementById(panelId + 'Content');
            const btn = panel.querySelector('.collapse-btn');

            if (!panel || !content) return;

            const isCollapsed = content.classList.contains('collapsed');

            if (isCollapsed) {
                // Expand
                content.classList.remove('collapsed');
                panel.classList.remove('collapsed');
                btn.textContent = '‚àí';
                btn.title = 'Collapse panel';
            } else {
                // Collapse
                content.classList.add('collapsed');
                panel.classList.add('collapsed');
                btn.textContent = '+';
                btn.title = 'Expand panel';
            }
        }
    </script>
</body>

</html>