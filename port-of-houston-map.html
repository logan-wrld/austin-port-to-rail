<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Port of Houston Map - Houston & Galveston Area</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
        #map { height: 100vh; width: 100%; }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 280px;
        }
        .info-panel h2 { font-size: 16px; margin-bottom: 8px; color: #1a365d; }
        .info-panel p { font-size: 12px; color: #666; margin-bottom: 5px; }
        .legend { margin-top: 10px; }
        .legend-item { display: flex; align-items: center; margin: 5px 0; font-size: 11px; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .legend-ship { width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-bottom: 14px solid #f6ad55; margin-right: 8px; }
        .terminal { background: #e53e3e; }
        .container { background: #3182ce; }
        .facility { background: #38a169; }
        .ship { background: #f6ad55; }
        
        .controls { margin-top: 12px; padding-top: 12px; border-top: 1px solid #eee; }
        .btn {
            display: inline-block;
            padding: 8px 12px;
            background: #3182ce;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .btn:hover { background: #2c5282; }
        .btn:disabled { background: #a0aec0; cursor: not-allowed; }
        .btn.danger { background: #e53e3e; }
        .btn.danger:hover { background: #c53030; }
        
        .ship-count { 
            background: #edf2f7; 
            padding: 8px 12px; 
            border-radius: 4px; 
            margin-top: 8px;
            font-size: 12px;
        }
        .ship-count strong { color: #2d3748; }
        
        .status { font-size: 11px; color: #718096; margin-top: 8px; }
        .status.loading { color: #3182ce; }
        .status.error { color: #e53e3e; }
        .status.success { color: #38a169; }
        
        .ship-icon {
            background: none;
            border: none;
        }
        
        .vessel-popup { min-width: 200px; }
        .vessel-popup h3 { margin: 0 0 8px 0; color: #1a365d; font-size: 14px; }
        .vessel-popup .detail { font-size: 12px; margin: 4px 0; color: #4a5568; }
        .vessel-popup .detail strong { color: #2d3748; }
        .vessel-type { 
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .type-cargo { background: #fbd38d; color: #744210; }
        .type-tanker { background: #feb2b2; color: #742a2a; }
        .type-container { background: #90cdf4; color: #2a4365; }
        .type-other { background: #cbd5e0; color: #1a202c; }
        
        /* Forecast panel styles */
        .forecast-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 320px;
            font-size: 12px;
        }
        .forecast-panel h3 { font-size: 14px; margin-bottom: 8px; color: #1a365d; }
        .forecast-row {
            padding: 8px;
            background: #f7fafc;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.6;
        }
        .forecast-label { color: #4a5568; }
        .forecast-sep { color: #cbd5e0; margin: 0 8px; }
        .forecast-summary {
            margin-top: 6px;
            padding: 6px 8px;
            background: #edf2f7;
            border-radius: 4px;
            font-size: 11px;
            color: #2d3748;
        }
        .forecast-stats {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e2e8f0;
            font-size: 11px;
            color: #718096;
        }
        .forecast-stats div { margin: 3px 0; }
        
        /* Rail styles */
        .legend-line { width: 20px; height: 3px; margin-right: 8px; border-radius: 2px; }
        .rail-up { background: #eab308; }
        .rail-bnsf { background: #f97316; }
        .rail-other { background: #6b7280; }
        
        .rail-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 220px;
            font-size: 12px;
        }
        .rail-panel h3 { font-size: 14px; margin-bottom: 8px; color: #1a365d; }
        .rail-stats { background: #f3f4f6; padding: 8px; border-radius: 4px; margin: 8px 0; }
        .rail-stats div { margin: 4px 0; }
        .rail-toggle { margin: 8px 0; }
        .rail-toggle label { display: flex; align-items: center; cursor: pointer; margin: 4px 0; }
        .rail-toggle input { margin-right: 8px; }
        
        .rail-popup { min-width: 180px; }
        .rail-popup h4 { margin: 0 0 6px 0; color: #1a365d; font-size: 13px; }
        .rail-popup .detail { font-size: 11px; margin: 3px 0; color: #4a5568; }
        .owner-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .owner-up { background: #fef3c7; color: #92400e; }
        .owner-bnsf { background: #ffedd5; color: #9a3412; }
        .owner-other { background: #e5e7eb; color: #374151; }
        
        /* Rail node styles */
        .node-marker {
            background: #7c3aed;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        .node-station {
            background: #dc2626;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .node-boundary {
            background: #0891b2;
            border: 2px solid white;
            border-radius: 50%;
        }
        .node-popup { min-width: 160px; }
        .node-popup h4 { margin: 0 0 6px 0; color: #1a365d; font-size: 13px; }
        .node-popup .detail { font-size: 11px; margin: 3px 0; color: #4a5568; }
        .node-type-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        .badge-station { background: #fee2e2; color: #991b1b; }
        .badge-junction { background: #f3e8ff; color: #6b21a8; }
        .badge-boundary { background: #cffafe; color: #0e7490; }
        .legend-node { width: 10px; height: 10px; border-radius: 50%; margin-right: 8px; border: 1px solid white; }
        .node-junction-color { background: #7c3aed; }
        .node-station-color { background: #dc2626; }
        
        /* Weather panel styles */
        .weather-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            max-width: 320px;
            max-height: 85vh;
            overflow-y: auto;
        }
        .weather-panel h3 { font-size: 16px; margin-bottom: 10px; color: #1a365d; }
        .weather-current {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .weather-current .temp {
            font-size: 32px;
            font-weight: bold;
            margin: 8px 0;
        }
        .weather-current .description {
            font-size: 14px;
            text-transform: capitalize;
            margin-bottom: 8px;
        }
        .weather-current .details {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin-top: 8px;
            opacity: 0.9;
        }
        .weather-forecast {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #eee;
        }
        .weather-forecast h4 {
            font-size: 13px;
            margin-bottom: 8px;
            color: #1a365d;
        }
        .forecast-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 4px 0;
            background: #f7fafc;
            border-radius: 4px;
            font-size: 12px;
        }
        .forecast-item .forecast-day {
            font-weight: 600;
            color: #2d3748;
            min-width: 80px;
        }
        .forecast-item .forecast-temp {
            color: #4a5568;
            font-weight: 500;
        }
        .forecast-item .forecast-icon {
            font-size: 18px;
        }
        .weather-icon {
            font-size: 48px;
            text-align: center;
            margin: 8px 0;
        }
        .weather-loading {
            text-align: center;
            padding: 20px;
            color: #718096;
            font-size: 12px;
        }
        .weather-error {
            text-align: center;
            padding: 20px;
            color: #e53e3e;
            font-size: 12px;
        }
        .weather-refresh-btn {
            margin-top: 8px;
            width: 100%;
        }
        .weather-overlay-toggle {
            margin-top: 8px;
            padding: 8px;
            background: #f7fafc;
            border-radius: 4px;
            font-size: 11px;
        }
        .weather-overlay-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            margin: 4px 0;
        }
        .weather-overlay-toggle input {
            margin-right: 8px;
        }
        
        /* Forecast Popup */
        .forecast-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        .forecast-popup.show {
            display: block;
        }
        .forecast-popup h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #1a365d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .forecast-popup .close-btn {
            background: #e53e3e;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 12px;
        }
        .forecast-popup .close-btn:hover {
            background: #c53030;
        }
        .forecast-popup-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }
        .forecast-popup-item {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }
        .forecast-popup-item .day {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
        }
        .forecast-popup-item .icon {
            font-size: 32px;
            margin: 8px 0;
        }
        .forecast-popup-item .temp {
            font-size: 16px;
            font-weight: bold;
            margin: 4px 0;
        }
        .forecast-popup-item .desc {
            font-size: 11px;
            opacity: 0.9;
            text-transform: capitalize;
            margin-top: 4px;
        }
        .forecast-popup-item .details {
            font-size: 10px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.3);
            opacity: 0.85;
        }
        .popup-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1999;
            display: none;
        }
        .popup-overlay.show {
            display: block;
        }
        
        /* AI Chat Panel Styles */
        .ai-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 380px;
            max-height: 450px;
            display: flex;
            flex-direction: column;
        }
        .ai-panel h3 { 
            font-size: 14px; 
            margin-bottom: 8px; 
            color: #1a365d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .ai-panel .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #48bb78;
            display: inline-block;
            margin-right: 6px;
        }
        .ai-panel .status-dot.offline { background: #fc8181; }
        .ai-panel .status-dot.loading { background: #f6e05e; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .ai-metrics {
            background: #f7fafc;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        .ai-metrics .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        .ai-metrics .metric-label { color: #718096; }
        .ai-metrics .metric-value { font-weight: 600; color: #2d3748; }
        .ai-metrics .risk-low { color: #38a169; }
        .ai-metrics .risk-medium { color: #dd6b20; }
        .ai-metrics .risk-high { color: #e53e3e; }
        
        .ai-chat-area {
            flex: 1;
            overflow-y: auto;
            max-height: 200px;
            margin-bottom: 8px;
            padding: 8px;
            background: #edf2f7;
            border-radius: 4px;
            font-size: 12px;
        }
        .ai-message {
            margin-bottom: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            max-width: 90%;
        }
        .ai-message.user {
            background: #3182ce;
            color: white;
            margin-left: auto;
        }
        .ai-message.assistant {
            background: white;
            color: #2d3748;
            border: 1px solid #e2e8f0;
        }
        .ai-message.error {
            background: #fed7d7;
            color: #c53030;
        }
        
        .ai-input-area {
            display: flex;
            gap: 6px;
        }
        .ai-input {
            flex: 1;
            padding: 8px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 12px;
        }
        .ai-input:focus {
            outline: none;
            border-color: #3182ce;
        }
        .ai-send-btn {
            padding: 8px 12px;
            background: #3182ce;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .ai-send-btn:hover { background: #2c5282; }
        .ai-send-btn:disabled { background: #a0aec0; cursor: not-allowed; }
        
        .ai-quick-btns {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }
        .ai-quick-btn {
            padding: 4px 8px;
            background: #edf2f7;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            color: #4a5568;
        }
        .ai-quick-btn:hover { background: #e2e8f0; }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- AI Analytics Panel -->
    <div class="ai-panel" id="aiPanel">
        <h3>
            <span><span class="status-dot" id="aiStatusDot"></span>AI Analytics</span>
            <button class="btn" style="padding:4px 8px; font-size:10px;" onclick="refreshMetrics()">Refresh</button>
        </h3>
        
        <!-- Current Metrics -->
        <div class="ai-metrics" id="aiMetrics">
            <div class="metric-row">
                <span class="metric-label">TEU/hour:</span>
                <span class="metric-value" id="metricTeu">--</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Deviation:</span>
                <span class="metric-value" id="metricDeviation">--</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Surge Risk:</span>
                <span class="metric-value" id="metricRisk">--</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Vessels in Channel:</span>
                <span class="metric-value" id="metricVessels">--</span>
            </div>
        </div>
        
        <!-- Quick Action Buttons -->
        <div class="ai-quick-btns">
            <button class="ai-quick-btn" onclick="askAI('What is the expected TEU volume per hour?')">TEU Volume</button>
            <button class="ai-quick-btn" onclick="askAI('What is the current surge risk and why?')">Surge Risk</button>
            <button class="ai-quick-btn" onclick="askAI('When are the next high-risk periods?')">Peak Hours</button>
            <button class="ai-quick-btn" onclick="askAI('What rail dispatch actions do you recommend?')">Recommendations</button>
        </div>
        
        <!-- Chat Area -->
        <div class="ai-chat-area" id="aiChatArea">
            <div class="ai-message assistant">Ask me about port metrics, surge predictions, or rail recommendations.</div>
        </div>
        
        <!-- Input Area -->
        <div class="ai-input-area">
            <input type="text" class="ai-input" id="aiInput" placeholder="Ask about TEU, surge risk, etc..." 
                   onkeypress="if(event.key==='Enter') sendAIMessage()">
            <button class="ai-send-btn" id="aiSendBtn" onclick="sendAIMessage()">Send</button>
        </div>
    </div>
    
    <!-- Forecast Popup Overlay -->
    <div class="popup-overlay" id="forecastOverlay" onclick="closeForecastPopup()"></div>
    <div class="forecast-popup" id="forecastPopup">
        <h3>
            <span>üìÖ 5-Day Weather Forecast</span>
            <button class="close-btn" onclick="closeForecastPopup()">‚úï Close</button>
        </h3>
        <div id="forecastPopupContent">
            <div class="weather-loading">Loading forecast...</div>
        </div>
    </div>
    
    <!-- Weather Panel -->
    <div class="weather-panel">
        <h3>üå§Ô∏è Weather</h3>
        <div id="weatherContent">
            <div class="weather-loading">Loading weather data...</div>
        </div>
        <button class="btn weather-refresh-btn" onclick="loadWeatherData()">üîÑ Refresh Weather</button>
    </div>
    
    <!-- Map Controls Panel -->
    <div class="rail-panel">
        <h3>üó∫Ô∏è Map Controls</h3>
        <div class="rail-stats">
            <div><strong>Total Segments:</strong> <span id="railCount">0</span></div>
            <div><strong>Total Miles:</strong> <span id="railMiles">0</span></div>
        </div>
        <div class="rail-toggle">
            <label><input type="checkbox" id="toggleRainOverlay" onchange="toggleRainOverlay()"> üåßÔ∏è Show Rain Overlay</label>
            <label><input type="checkbox" id="toggleRail" checked onchange="toggleRailLayer()"> üöÇ Show Rail Lines</label>
            <label><input type="checkbox" id="toggleNodes" onchange="toggleNodeLayer()"> üöâ Show Rail Nodes</label>
            <label><input type="checkbox" id="toggleUP" checked onchange="filterRailByOwner()"> Union Pacific (UP)</label>
            <label><input type="checkbox" id="toggleBNSF" checked onchange="filterRailByOwner()"> BNSF Railway</label>
            <label><input type="checkbox" id="toggleOther" checked onchange="filterRailByOwner()"> Other Railroads</label>
        </div>
        <div class="rail-stats" style="margin-top:8px;">
            <div><strong>Rail Nodes:</strong> <span id="nodeCount">0</span></div>
            <div><strong>Stations:</strong> <span id="stationCount">0</span></div>
        </div>
        <div class="legend" style="margin-top:8px; padding-top:8px; border-top:1px solid #eee;">
            <div class="legend-item"><span class="legend-line rail-up"></span> Union Pacific</div>
            <div class="legend-item"><span class="legend-line rail-bnsf"></span> BNSF Railway</div>
            <div class="legend-item"><span class="legend-line rail-other"></span> Other (USG, TCT, etc.)</div>
            <div class="legend-item"><span class="legend-node node-junction-color"></span> Junction Node</div>
            <div class="legend-item"><span class="legend-node node-station-color"></span> Passenger Station</div>
        </div>
    </div>
    
    <div class="info-panel">
        <h2>üö¢ Port of Houston</h2>
        <p>AIS Ship Tracking</p>
        
        <div class="ship-count">
            <strong>Vessels Tracked:</strong> <span id="shipCount">0</span>
        </div>
        
        <div class="controls">
            <button class="btn" id="refreshBtn" onclick="loadAISData()">üîÑ Refresh</button>
            <button class="btn" id="autoRefreshBtn" onclick="toggleAutoRefresh()">‚ñ∂Ô∏è Auto</button>
            <button class="btn danger" onclick="clearShips()">üóëÔ∏è Clear</button>
        </div>
        
        <div id="status" class="status">Ready to load vessels</div>
        
        <div class="data-source" style="margin-top:10px; padding:8px; background:#fffbeb; border-radius:4px; font-size:10px; color:#92400e;">
            <strong>üì° Data Mode:</strong> <span id="dataMode">Simulated</span><br>
            <span style="color:#78716c;">Ships positioned along actual shipping lanes</span>
        </div>
        
        <div class="legend">
            <div class="legend-item"><span class="legend-ship"></span> Vessels (AIS)</div>
            <div class="legend-item"><span class="legend-dot terminal"></span> Terminals</div>
            <div class="legend-item"><span class="legend-dot container"></span> Container Facilities</div>
            <div class="legend-item"><span class="legend-dot facility"></span> Other Facilities</div>
            <div class="legend-item" style="margin-top:5px; padding-top:5px; border-top:1px solid #eee;"><span class="legend-line rail-up" style="display:inline-block;"></span> Rail Network</div>
        </div>
    </div>

    <!-- Ship Arrival Forecast Panel -->
    <div class="forecast-panel" id="forecastPanel">
        <h3>72-Hour Ship Forecast</h3>
        <div id="forecastContent">
            <div style="color:#718096; font-style:italic;">Loading forecast...</div>
        </div>
        <div class="forecast-stats" id="forecastStats"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="js/ship-forecasting.js"></script>
    <script>
        // Initialize map centered on Port of Houston / Galveston Bay area
        const map = L.map('map', {
            minZoom: 10,
            maxBounds: [
                [29.2, -95.5],  // Southwest corner
                [30.0, -94.5]    // Northeast corner
            ],
            maxBoundsViscosity: 1.0  // Prevent panning outside bounds
        }).setView([29.6, -94.85], 11);

        // Add OpenStreetMap tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Layer groups
        const facilitiesLayer = L.layerGroup().addTo(map);
        const shipsLayer = L.layerGroup().addTo(map);
        const railLayer = L.layerGroup().addTo(map);
        const nodesLayer = L.layerGroup(); // Not added by default (too many nodes)
        
        // Rain/precipitation overlay layer
        let rainOverlayLayer = null;
        
        // Store forecast data for popup
        let storedForecastData = null;
        
        // Rail data storage
        let railSegments = [];
        let railNodes = [];
        let nodeMap = new Map(); // Map of nodeId -> {lat, lng}
        
        // Auto-refresh state
        let autoRefreshInterval = null;
        let isAutoRefreshing = false;
        
        // Weather API configuration
        // Get free API key at https://openweathermap.org/api
        const WEATHER_API_KEY = ''; // Add your OpenWeatherMap API key here
        const WEATHER_LAT = 29.6;   // Houston/Galveston area latitude
        const WEATHER_LON = -94.85; // Houston/Galveston area longitude

        // Port facilities data - Houston and Galveston area
        const facilities = [
            { name: "Barbours Cut Container Terminal", lat: 29.7234, lng: -95.0012, type: "terminal", desc: "Major container terminal" },
            { name: "Bayport Container Terminal", lat: 29.6234, lng: -94.9912, type: "terminal", desc: "Modern container facility" },
            { name: "Turning Basin Terminal", lat: 29.7355, lng: -95.2755, type: "terminal", desc: "General cargo terminal" },
            { name: "Care Terminal", lat: 29.7156, lng: -95.0234, type: "container", desc: "Container handling" },
            { name: "Jacintoport Terminal", lat: 29.7456, lng: -95.0834, type: "container", desc: "Break-bulk cargo" },
            { name: "Galena Park Terminal", lat: 29.7356, lng: -95.2155, type: "facility", desc: "Industrial terminal" },
            { name: "Manchester Terminal", lat: 29.7256, lng: -95.2555, type: "facility", desc: "Bulk cargo facility" },
            { name: "Greens Bayou Terminal", lat: 29.7756, lng: -95.1255, type: "facility", desc: "General cargo" },
            { name: "Galveston Wharves", lat: 29.3108, lng: -94.7872, type: "terminal", desc: "Cruise & cargo terminal" },
            { name: "Texas City Terminal", lat: 29.3834, lng: -94.9134, type: "facility", desc: "Petrochemical terminal" }
        ];

        // Color mapping for facilities
        const colors = {
            terminal: '#e53e3e',
            container: '#3182ce',
            facility: '#38a169'
        };

        // Add facility markers
        facilities.forEach(f => {
            const marker = L.circleMarker([f.lat, f.lng], {
                radius: 8,
                fillColor: colors[f.type],
                color: '#fff',
                weight: 2,
                fillOpacity: 0.8
            }).addTo(facilitiesLayer);
            marker.bindPopup(`<strong>${f.name}</strong><br>${f.desc}`);
        });

        // Draw Houston Ship Channel (from Galveston Bay to Turning Basin)
        const channelPath = [
            [29.35, -94.82],      // Galveston Bay entrance
            [29.55, -94.92],
            [29.68, -94.98],      // Morgan's Point area
            [29.7234, -95.0012],  // Barbours Cut
            [29.7355, -95.0555],
            [29.7355, -95.1555],
            [29.7355, -95.2555],
            [29.7355, -95.2955]   // Turning Basin
        ];

        L.polyline(channelPath, {
            color: '#4299e1',
            weight: 4,
            opacity: 0.5,
            dashArray: '10, 10'
        }).addTo(facilitiesLayer).bindPopup('Houston Ship Channel');

        // Create ship icon based on heading
        function createShipIcon(heading, shipType) {
            const color = getShipColor(shipType);
            const rotation = heading || 0;
            
            return L.divIcon({
                className: 'ship-icon',
                html: `<svg width="24" height="24" viewBox="0 0 24 24" style="transform: rotate(${rotation}deg);">
                    <path d="M12 2 L18 20 L12 16 L6 20 Z" fill="${color}" stroke="#fff" stroke-width="1.5"/>
                </svg>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
        }

        // Get ship color based on type
        function getShipColor(shipType) {
            const type = (shipType || '').toLowerCase();
            if (type.includes('tanker') || type.includes('oil')) return '#e53e3e';
            if (type.includes('container')) return '#3182ce';
            if (type.includes('cargo') || type.includes('bulk')) return '#f6ad55';
            if (type.includes('tug')) return '#805ad5';
            return '#718096';
        }

        // Get vessel type class for popup styling
        function getTypeClass(shipType) {
            const type = (shipType || '').toLowerCase();
            if (type.includes('tanker')) return 'type-tanker';
            if (type.includes('container')) return 'type-container';
            if (type.includes('cargo') || type.includes('bulk')) return 'type-cargo';
            return 'type-other';
        }

        // Format speed
        function formatSpeed(speed) {
            if (!speed || speed < 0) return 'N/A';
            return `${speed.toFixed(1)} knots`;
        }

        // Update status display
        function setStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
        }

        // AISStream WebSocket connection (for real-time data)
        let aisSocket = null;
        const AIS_API_KEY = ''; // Get free key at https://aisstream.io
        
        // Load AIS data - tries multiple sources
        async function loadAISData() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            setStatus('Loading vessel data...', 'loading');
            
            // If we have an API key, use real-time WebSocket
            if (AIS_API_KEY) {
                connectToAISStream();
                return;
            }
            
            try {
                // Bounding box for Houston/Galveston area
                const minLat = 29.2;
                const maxLat = 29.9;
                const minLon = -95.4;
                const maxLon = -94.7;
                
                // Try ArcGIS Maritime service
                const response = await fetch(
                    `https://services.arcgis.com/LBbVDC0hKPAnLRpO/arcgis/rest/services/AIS_Vessel_Tracks/FeatureServer/0/query?` +
                    `where=1%3D1&geometry=${minLon}%2C${minLat}%2C${maxLon}%2C${maxLat}&geometryType=esriGeometryEnvelope&` +
                    `inSR=4326&spatialRel=esriSpatialRelIntersects&outFields=*&returnGeometry=true&f=json`,
                    { signal: AbortSignal.timeout(8000) }
                );
                
                if (!response.ok) throw new Error('AIS API unavailable');
                
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const vessels = data.features.map(f => ({
                        lat: f.geometry.y || f.geometry.points?.[0]?.[1],
                        lng: f.geometry.x || f.geometry.points?.[0]?.[0],
                        name: f.attributes.VesselName || f.attributes.VESSEL_NAME || 'Unknown Vessel',
                        mmsi: f.attributes.MMSI || f.attributes.mmsi,
                        heading: f.attributes.Heading || f.attributes.COG || 0,
                        speed: f.attributes.SOG || f.attributes.Speed || 0,
                        type: f.attributes.VesselType || f.attributes.VESSEL_TYPE || 'Cargo',
                        destination: f.attributes.Destination || 'Unknown',
                        flag: f.attributes.Flag || '',
                        length: f.attributes.Length || 'N/A',
                        draft: f.attributes.Draft || 'N/A'
                    })).filter(v => v.lat && v.lng);
                    
                    if (vessels.length > 0) {
                        document.getElementById('dataMode').textContent = 'Live (ArcGIS)';
                        document.getElementById('dataMode').parentElement.style.background = '#d1fae5';
                        displayVessels(vessels);
                        refreshBtn.disabled = false;
                        return;
                    }
                }
                throw new Error('No vessels in response');
                
            } catch (error) {
                console.log('API unavailable, using simulation:', error.message);
                document.getElementById('dataMode').textContent = 'Simulated Demo';
                document.getElementById('dataMode').parentElement.style.background = '#fffbeb';
                displayVessels(generateSimulatedVessels());
            }
            
            refreshBtn.disabled = false;
        }
        
        // Connect to AISStream.io for real-time data
        function connectToAISStream() {
            if (!AIS_API_KEY) return;
            
            if (aisSocket) {
                aisSocket.close();
            }
            
            setStatus('Connecting to AIS stream...', 'loading');
            
            aisSocket = new WebSocket('wss://stream.aisstream.io/v0/stream');
            
            aisSocket.onopen = () => {
                // Subscribe to Houston/Galveston area
                const subscribeMsg = {
                    APIKey: AIS_API_KEY,
                    BoundingBoxes: [[[-95.4, 29.2], [-94.7, 29.9]]]
                };
                aisSocket.send(JSON.stringify(subscribeMsg));
                setStatus('Connected to live AIS stream', 'success');
                document.getElementById('dataMode').textContent = 'Live (AISStream)';
                document.getElementById('dataMode').parentElement.style.background = '#d1fae5';
            };
            
            const liveVessels = new Map();
            
            aisSocket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.MessageType === 'PositionReport') {
                    const pos = msg.Message.PositionReport;
                    const meta = msg.MetaData;
                    
                    liveVessels.set(meta.MMSI, {
                        mmsi: meta.MMSI,
                        name: meta.ShipName || `Vessel ${meta.MMSI}`,
                        lat: pos.Latitude,
                        lng: pos.Longitude,
                        heading: pos.TrueHeading || pos.Cog || 0,
                        speed: pos.Sog || 0,
                        type: meta.ShipType || 'Unknown',
                        destination: meta.Destination || 'Unknown',
                        flag: meta.Flag || '',
                        length: meta.Length || 'N/A',
                        draft: meta.Draught || 'N/A',
                        lastSeen: Date.now()
                    });
                    
                    // Cleanup old vessels (not seen in 5 minutes)
                    const VESSEL_TIMEOUT = 5 * 60 * 1000;
                    const now = Date.now();
                    for (const [mmsi, vessel] of liveVessels.entries()) {
                        if (now - (vessel.lastSeen || 0) > VESSEL_TIMEOUT) {
                            liveVessels.delete(mmsi);
                        }
                    }
                    
                    // Update display every 10 vessels received
                    if (liveVessels.size % 10 === 0) {
                        displayVessels(Array.from(liveVessels.values()));
                    }
                }
            };
            
            aisSocket.onerror = (error) => {
                console.error('AIS WebSocket error:', error);
                setStatus('Stream error, using simulation', 'error');
                displayVessels(generateSimulatedVessels());
            };
            
            aisSocket.onclose = () => {
                setStatus('Stream disconnected', '');
            };
            
            document.getElementById('refreshBtn').disabled = false;
        }

        // Generate simulated vessels for demo purposes
        // These are realistic positions along the Houston Ship Channel
        function generateSimulatedVessels() {
            // Real vessel names that commonly visit Port of Houston
            const vesselNames = [
                'MSC AURORA', 'MAERSK SEALAND', 'EVER GOLDEN', 'CMA CGM MARCO POLO',
                'COSCO SHIPPING ARIES', 'HAPAG-LLOYD EXPRESS', 'YANG MING UNITY',
                'ONE COLUMBA', 'HYUNDAI BRAVE', 'ZIM SAVANNAH', 'OOCL ATLANTA',
                'PIL PUSAN', 'MEDITERRANEAN STAR', 'ATLANTIC VOYAGER', 'GULF TRADER',
                'HOUSTON EXPRESS', 'TEXAS ENTERPRISE', 'BAYPORT CARRIER', 'CHANNEL RUNNER',
                'GALVESTON BAY', 'LONE STAR TANKER', 'ENERGY FRONTIER', 'PETROCHEMICAL HOUSTON'
            ];
            
            const vesselTypes = ['Cargo', 'Container Ship', 'Tanker', 'Bulk Carrier', 'Chemical Tanker', 'LNG Tanker', 'Tug'];
            const destinations = ['HOUSTON TX', 'GALVESTON TX', 'TEXAS CITY TX', 'BAYPORT TX', 'BARBOURS CUT TX', 'LA PORTE TX'];
            const flags = ['US', 'PA', 'LR', 'MH', 'SG', 'HK', 'GR', 'MT', 'BS', 'CY', 'NO', 'DK'];
            
            const vessels = [];
            const numVessels = 28 + Math.floor(Math.random() * 12); // More vessels for extended range
            
            // Define realistic ship positions along the Houston Ship Channel and Galveston Bay
            const shipPositions = [
                // Deep Gulf of Mexico - ships 80-120nm out (48-72 hour ETA)
                { lat: 27.8, lng: -93.5, heading: 315, zone: 'deep-gulf' },
                { lat: 27.9, lng: -93.8, heading: 320, zone: 'deep-gulf' },
                { lat: 28.0, lng: -94.0, heading: 325, zone: 'deep-gulf' },
                { lat: 28.1, lng: -93.6, heading: 318, zone: 'deep-gulf' },
                // Mid Gulf - ships 50-80nm out (24-48 hour ETA)
                { lat: 28.3, lng: -94.0, heading: 330, zone: 'mid-gulf' },
                { lat: 28.4, lng: -94.2, heading: 328, zone: 'mid-gulf' },
                { lat: 28.5, lng: -93.9, heading: 332, zone: 'mid-gulf' },
                { lat: 28.55, lng: -94.1, heading: 335, zone: 'mid-gulf' },
                // Near Gulf - ships 20-50nm out (12-24 hour ETA)
                { lat: 28.7, lng: -94.2, heading: 338, zone: 'near-gulf' },
                { lat: 28.8, lng: -94.3, heading: 340, zone: 'near-gulf' },
                { lat: 28.95, lng: -94.35, heading: 340, zone: 'gulf' },
                { lat: 29.02, lng: -94.42, heading: 335, zone: 'gulf' },
                { lat: 29.08, lng: -94.48, heading: 332, zone: 'gulf' },
                { lat: 29.15, lng: -94.55, heading: 330, zone: 'gulf' },
                { lat: 29.22, lng: -94.62, heading: 328, zone: 'gulf' },
                // Galveston Bay approach - ships entering
                { lat: 29.28, lng: -94.68, heading: 330, zone: 'approach' },
                { lat: 29.32, lng: -94.72, heading: 330, zone: 'approach' },
                { lat: 29.36, lng: -94.76, heading: 325, zone: 'approach' },
                { lat: 29.40, lng: -94.78, heading: 320, zone: 'bay' },
                // Galveston Bay - ships transiting
                { lat: 29.40, lng: -94.78, heading: 320, zone: 'bay' },
                { lat: 29.45, lng: -94.82, heading: 315, zone: 'bay' },
                { lat: 29.50, lng: -94.86, heading: 310, zone: 'bay' },
                { lat: 29.53, lng: -94.88, heading: 305, zone: 'bay' },
                // Entering Houston Ship Channel from Morgan's Point
                { lat: 29.58, lng: -94.91, heading: 300, zone: 'channel' },
                { lat: 29.62, lng: -94.94, heading: 295, zone: 'channel' },
                { lat: 29.66, lng: -94.97, heading: 290, zone: 'channel' },
                { lat: 29.68, lng: -94.98, heading: 290, zone: 'channel' },
                { lat: 29.69, lng: -95.00, heading: 285, zone: 'channel' },
                // Mid channel near Bayport
                { lat: 29.71, lng: -95.02, heading: 280, zone: 'channel' },
                { lat: 29.72, lng: -95.05, heading: 275, zone: 'channel' },
                { lat: 29.72, lng: -95.08, heading: 270, zone: 'channel' },
                // Near Jacintoport
                { lat: 29.73, lng: -95.10, heading: 270, zone: 'channel' },
                { lat: 29.73, lng: -95.12, heading: 268, zone: 'channel' },
                { lat: 29.73, lng: -95.15, heading: 265, zone: 'channel' },
                // Approaching Turning Basin
                { lat: 29.74, lng: -95.18, heading: 265, zone: 'upper' },
                { lat: 29.74, lng: -95.22, heading: 260, zone: 'upper' },
                { lat: 29.74, lng: -95.26, heading: 255, zone: 'upper' },
                // At terminals (stationary/slow)
                { lat: 29.72, lng: -95.00, heading: 45, zone: 'terminal', speed: 0 },
                { lat: 29.62, lng: -94.99, heading: 90, zone: 'terminal', speed: 0 },
                { lat: 29.74, lng: -95.27, heading: 180, zone: 'terminal', speed: 0.5 },
                { lat: 29.31, lng: -94.79, heading: 90, zone: 'terminal', speed: 0 }, // Galveston
            ];
            
            for (let i = 0; i < Math.min(numVessels, shipPositions.length + 5); i++) {
                let pos;
                if (i < shipPositions.length) {
                    pos = shipPositions[i];
                    // Add small random offset for realism
                    pos = {
                        ...pos,
                        lat: pos.lat + (Math.random() - 0.5) * 0.015,
                        lng: pos.lng + (Math.random() - 0.5) * 0.015,
                        heading: pos.heading + (Math.random() - 0.5) * 15
                    };
                } else {
                    // Extra random ships - in Houston/Galveston area
                    const inBay = Math.random() > 0.5;
                    if (inBay) {
                        pos = {
                            lat: 29.35 + Math.random() * 0.25,
                            lng: -94.85 + (Math.random() - 0.5) * 0.2,
                            heading: 300 + Math.random() * 60,
                            zone: 'bay'
                        };
                    } else {
                        pos = {
                            lat: 29.68 + Math.random() * 0.08,
                            lng: -95.00 + (Math.random() - 0.5) * 0.3,
                            heading: 260 + Math.random() * 40,
                            zone: 'channel'
                        };
                    }
                }
                
                // Speed based on zone
                let speed;
                if (pos.speed !== undefined) {
                    speed = pos.speed;
                } else if (pos.zone === 'terminal') {
                    speed = Math.random() * 1;
                } else if (pos.zone === 'channel' || pos.zone === 'upper') {
                    speed = 6 + Math.random() * 6; // 6-12 knots in channel
                } else if (pos.zone === 'bay') {
                    speed = 10 + Math.random() * 8; // 10-18 knots in bay
                } else {
                    speed = 8 + Math.random() * 6; // 8-14 knots
                }
                
                const vesselType = vesselTypes[Math.floor(Math.random() * vesselTypes.length)];
                
                vessels.push({
                    mmsi: 300000000 + Math.floor(Math.random() * 99999999),
                    name: vesselNames[i % vesselNames.length],
                    lat: pos.lat,
                    lng: pos.lng,
                    heading: pos.heading,
                    speed: speed,
                    type: vesselType,
                    destination: destinations[Math.floor(Math.random() * destinations.length)],
                    flag: flags[Math.floor(Math.random() * flags.length)],
                    length: vesselType.includes('Container') ? 300 + Math.floor(Math.random() * 100) : 
                            vesselType.includes('Tanker') ? 200 + Math.floor(Math.random() * 150) :
                            vesselType.includes('Tug') ? 25 + Math.floor(Math.random() * 15) :
                            100 + Math.floor(Math.random() * 200),
                    draft: vesselType.includes('Tanker') ? 12 + Math.random() * 8 : 8 + Math.random() * 8
                });
            }
            
            return vessels;
        }

        // Display vessels on map
        function displayVessels(vessels) {
            shipsLayer.clearLayers();
            let count = 0;
            
            vessels.forEach(v => {
                // Handle different API response formats
                const lat = v.lat || v.geometry?.coordinates?.[1] || v.properties?.latitude;
                const lng = v.lng || v.geometry?.coordinates?.[0] || v.properties?.longitude;
                const name = v.name || v.properties?.name || `Vessel ${v.mmsi}`;
                const heading = v.heading || v.properties?.heading || v.cog || 0;
                const speed = v.speed || v.properties?.sog || 0;
                const type = v.type || v.properties?.shipType || 'Unknown';
                const mmsi = v.mmsi || v.properties?.mmsi || 'Unknown';
                const destination = v.destination || v.properties?.destination || 'Unknown';
                const flag = v.flag || v.properties?.flag || '';
                const length = v.length || v.properties?.length || 'N/A';
                const draft = v.draft || v.properties?.draft || 'N/A';
                
                if (!lat || !lng) return;
                
                const icon = createShipIcon(heading, type);
                const marker = L.marker([lat, lng], { icon: icon }).addTo(shipsLayer);
                
                const typeClass = getTypeClass(type);
                marker.bindPopup(`
                    <div class="vessel-popup">
                        <h3>üö¢ ${name}</h3>
                        <span class="vessel-type ${typeClass}">${type}</span>
                        <div class="detail"><strong>MMSI:</strong> ${mmsi}</div>
                        <div class="detail"><strong>Flag:</strong> ${flag || 'Unknown'}</div>
                        <div class="detail"><strong>Speed:</strong> ${formatSpeed(speed)}</div>
                        <div class="detail"><strong>Heading:</strong> ${heading ? heading.toFixed(0) + '¬∞' : 'N/A'}</div>
                        <div class="detail"><strong>Destination:</strong> ${destination}</div>
                        <div class="detail"><strong>Length:</strong> ${typeof length === 'number' ? length + ' m' : length}</div>
                        <div class="detail"><strong>Draft:</strong> ${typeof draft === 'number' ? draft.toFixed(1) + ' m' : draft}</div>
                    </div>
                `);
                
                count++;
            });
            
            document.getElementById('shipCount').textContent = count;
            setStatus(`Updated: ${new Date().toLocaleTimeString()}`, 'success');
            
            // Update forecast panel with ship data
            updateForecastPanel(vessels);
        }

        // Update the 72-hour forecast panel
        function updateForecastPanel(vessels) {
            if (!vessels || vessels.length === 0) {
                document.getElementById('forecastContent').innerHTML = 
                    '<div style="color:#718096; font-style:italic;">No vessels to forecast</div>';
                return;
            }
            
            // Normalize vessel data for forecasting
            const normalizedVessels = vessels.map(v => ({
                name: v.name || v.properties?.name || `Vessel ${v.mmsi}`,
                lat: v.lat || v.geometry?.coordinates?.[1] || v.properties?.latitude,
                lon: v.lng || v.geometry?.coordinates?.[0] || v.properties?.longitude,
                speed: v.speed || v.properties?.sog || 10
            })).filter(v => v.lat && v.lon);
            
            // Get forecast from ShipForecasting module
            const summary = ShipForecasting.getSummary(normalizedVessels);
            const forecast = summary.forecast;
            
            // Build forecast HTML - simple inline format
            const w24 = forecast.windows["0-24h"];
            const w48 = forecast.windows["24-48h"];
            const w72 = forecast.windows["48-72h"];
            
            let html = `
                <div class="forecast-row">
                    <span class="forecast-label">0-24h:</span> <strong>${w24.count}</strong> ships
                    <span class="forecast-sep">|</span>
                    <span class="forecast-label">24-48h:</span> <strong>${w48.count}</strong> ships
                    <span class="forecast-sep">|</span>
                    <span class="forecast-label">48-72h:</span> <strong>${w72.count}</strong> ships
                </div>
                <div class="forecast-summary">
                    Total: <strong>${w24.count + w48.count + w72.count}</strong> ships in 72h window
                </div>
            `;
            
            document.getElementById('forecastContent').innerHTML = html;
            
            // Update stats
            let statsHtml = `
                <div><strong>Avg arrival gap:</strong> ${summary.avgArrivalGap}</div>
                <div><strong>Est. arrivals/day:</strong> ${summary.arrivalsPerDay}</div>
            `;
            if (summary.closestShips) {
                statsHtml += `<div><strong>Closest ships:</strong> ${summary.closestShips.distance} nm apart</div>`;
            }
            statsHtml += `<div style="margin-top:4px; font-size:10px; color:#a0aec0;">Updated: ${forecast.generatedAt}</div>`;
            
            document.getElementById('forecastStats').innerHTML = statsHtml;
        }

        // Clear ships from map
        function clearShips() {
            shipsLayer.clearLayers();
            document.getElementById('shipCount').textContent = '0';
            setStatus('Vessels cleared', '');
        }

        // Toggle auto-refresh
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            
            if (isAutoRefreshing) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                isAutoRefreshing = false;
                btn.textContent = '‚ñ∂Ô∏è Auto';
                setStatus('Auto-refresh stopped', '');
            } else {
                loadAISData();
                autoRefreshInterval = setInterval(loadAISData, 60000); // Refresh every 60 seconds
                isAutoRefreshing = true;
                btn.textContent = '‚è∏Ô∏è Auto';
                setStatus('Auto-refresh enabled (60s)', 'success');
            }
        }

        // ========== RAIL NETWORK DATA & VISUALIZATION ==========
        // Rail owner colors
        const railColors = {
            'UP': '#eab308',      // Yellow for Union Pacific
            'BNSF': '#f97316',    // Orange for BNSF
            'TCT': '#6366f1',     // Indigo for Texas City Terminal
            'USG': '#6b7280',     // Gray for US Government
            'BRG': '#10b981',     // Emerald
            'AWRR': '#8b5cf6',    // Violet
            'FWWR': '#ec4899',    // Pink
            'default': '#6b7280'  // Gray default
        };
        
        // Get owner badge class
        function getOwnerClass(owner) {
            if (owner === 'UP') return 'owner-up';
            if (owner === 'BNSF') return 'owner-bnsf';
            return 'owner-other';
        }
        
        // Draw rail network dynamically from CSV data
        async function drawRailNetwork() {
            railLayer.clearLayers();
            railSegments = [];
            
            // Ensure nodes are loaded first
            if (nodeMap.size === 0) {
                await loadRailNodes();
            }
            
            // Load rail lines from CSV
            const railLines = await loadRailLines();
            
            if (railLines.length === 0) {
                console.warn('No rail lines loaded');
                document.getElementById('railCount').textContent = '0';
                document.getElementById('railMiles').textContent = '0';
                return;
            }
            
            const showUP = document.getElementById('toggleUP').checked;
            const showBNSF = document.getElementById('toggleBNSF').checked;
            const showOther = document.getElementById('toggleOther').checked;
            
            let totalMiles = 0;
            let segmentCount = 0;
            
            railLines.forEach(rail => {
                // Filter by owner
                if (rail.owner === 'UP' && !showUP) return;
                if (rail.owner === 'BNSF' && !showBNSF) return;
                if (!['UP', 'BNSF'].includes(rail.owner) && !showOther) return;
                
                const color = railColors[rail.owner] || railColors['default'];
                const weight = rail.tracks > 1 ? 4 : 3;
                
                const line = L.polyline(rail.coords, {
                    color: color,
                    weight: weight,
                    opacity: 0.8,
                    lineCap: 'round',
                    lineJoin: 'round'
                }).addTo(railLayer);
                
                // Popup with rail info
                line.bindPopup(`
                    <div class="rail-popup">
                        <span class="owner-badge ${getOwnerClass(rail.owner)}">${rail.owner}</span>
                        <h4>üõ§Ô∏è ${rail.subdiv || 'Rail Segment'}</h4>
                        <div class="detail"><strong>Owner:</strong> ${getOwnerFullName(rail.owner)}</div>
                        <div class="detail"><strong>Miles:</strong> ${rail.miles.toFixed(2)}</div>
                        <div class="detail"><strong>Tracks:</strong> ${rail.tracks}</div>
                    </div>
                `);
                
                railSegments.push({ line, data: rail });
                totalMiles += rail.miles;
                segmentCount++;
            });
            
            // Update stats
            document.getElementById('railCount').textContent = segmentCount;
            document.getElementById('railMiles').textContent = totalMiles.toFixed(1);
        }
        
        // Get full railroad name
        function getOwnerFullName(code) {
            const names = {
                'UP': 'Union Pacific Railroad',
                'BNSF': 'BNSF Railway',
                'TCT': 'Texas City Terminal Railway',
                'USG': 'US Government',
                'BRG': 'Brownsville & Rio Grande',
                'AWRR': 'Austin Western Railroad',
                'FWWR': 'Fort Worth & Western Railroad'
            };
            return names[code] || code;
        }
        
        // Toggle rail layer visibility
        async function toggleRailLayer() {
            const show = document.getElementById('toggleRail').checked;
            if (show) {
                map.addLayer(railLayer);
                await drawRailNetwork();
            } else {
                map.removeLayer(railLayer);
            }
        }
        
        // Filter rail by owner
        async function filterRailByOwner() {
            await drawRailNetwork();
        }
        
        // ========== RAIL NODES VISUALIZATION ==========
        
        // Load rail nodes from CSV file and build node map
        async function loadRailNodes() {
            try {
                const response = await fetch('data/railroad-nodes.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                
                // Skip header
                railNodes = [];
                nodeMap.clear();
                let stationCount = 0;
                
                for (let i = 1; i < lines.length; i++) {
                    const cols = lines[i].split(',');
                    if (cols.length < 13) continue;
                    
                    const x = parseFloat(cols[11]); // longitude
                    const y = parseFloat(cols[12]); // latitude
                    
                    // Filter to Houston/Galveston area
                    if (x < -95.5 || x > -94.5 || y < 29.2 || y > 30.0) continue;
                    
                    const nodeId = cols[1]; // FRANODEID
                    const node = {
                        objectId: cols[0],
                        fraNodeId: nodeId,
                        state: cols[3],
                        countyFips: cols[5],
                        stCountyFips: cols[6],
                        fraDistrict: cols[7],
                        passenger: cols[8],
                        stationName: cols[9],
                        boundary: parseInt(cols[10]) || 0,
                        lng: x,
                        lat: y
                    };
                    
                    railNodes.push(node);
                    // Store in map for quick lookup by node ID
                    if (nodeId) {
                        nodeMap.set(nodeId, { lat: y, lng: x });
                    }
                    
                    if (node.stationName) stationCount++;
                }
                
                console.log(`Loaded ${railNodes.length} rail nodes, ${stationCount} stations`);
                document.getElementById('nodeCount').textContent = railNodes.length.toLocaleString();
                document.getElementById('stationCount').textContent = stationCount;
                
                return railNodes;
            } catch (error) {
                console.error('Error loading rail nodes:', error);
                // Show user-friendly error feedback
                document.getElementById('nodeCount').textContent = 'Error';
                document.getElementById('stationCount').textContent = 'Error';
                return [];
            }
        }
        
        // Simple CSV parser that handles quoted fields
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }
        
        // Load rail lines from CSV file
        async function loadRailLines() {
            try {
                const response = await fetch('data/railroad-lines.csv');
                const csvText = await response.text();
                const lines = csvText.trim().split('\n');
                
                if (lines.length < 2) return [];
                
                const railLines = [];
                const header = parseCSVLine(lines[0]);
                
                // Find column indices
                const getColIndex = (name) => {
                    const idx = header.findIndex(h => h.trim() === name);
                    return idx >= 0 ? idx : -1;
                };
                
                const fromNodeIdx = getColIndex('FRFRANODE');
                const toNodeIdx = getColIndex('TOFRANODE');
                const ownerIdx = getColIndex('RROWNER1');
                const subdivIdx = getColIndex('SUBDIV');
                const tracksIdx = getColIndex('TRACKS');
                const milesIdx = getColIndex('MILES');
                
                if (fromNodeIdx < 0 || toNodeIdx < 0) {
                    console.error('Required columns not found in CSV');
                    return [];
                }
                
                // Houston/Galveston area bounds
                const minLat = 29.2;
                const maxLat = 30.0;
                const minLng = -95.5;
                const maxLng = -94.5;
                
                for (let i = 1; i < lines.length; i++) {
                    const cols = parseCSVLine(lines[i]);
                    if (cols.length < Math.max(fromNodeIdx, toNodeIdx, ownerIdx) + 1) continue;
                    
                    const fromNodeId = cols[fromNodeIdx]?.trim();
                    const toNodeId = cols[toNodeIdx]?.trim();
                    const owner = (ownerIdx >= 0 ? cols[ownerIdx]?.trim() : '') || '';
                    const subdiv = (subdivIdx >= 0 ? cols[subdivIdx]?.trim() : '') || '';
                    const tracks = (tracksIdx >= 0 ? parseInt(cols[tracksIdx]) : 1) || 1;
                    const miles = (milesIdx >= 0 ? parseFloat(cols[milesIdx]) : 0) || 0;
                    
                    if (!fromNodeId || !toNodeId) continue;
                    
                    // Get coordinates from node map
                    const fromNode = nodeMap.get(fromNodeId);
                    const toNode = nodeMap.get(toNodeId);
                    
                    if (!fromNode || !toNode) continue;
                    
                    // Filter to Houston/Galveston area
                    if (fromNode.lat < minLat || fromNode.lat > maxLat || 
                        fromNode.lng < minLng || fromNode.lng > maxLng ||
                        toNode.lat < minLat || toNode.lat > maxLat ||
                        toNode.lng < minLng || toNode.lng > maxLng) {
                        continue;
                    }
                    
                    railLines.push({
                        fromNodeId: fromNodeId,
                        toNodeId: toNodeId,
                        owner: owner,
                        subdiv: subdiv,
                        tracks: tracks,
                        miles: miles,
                        coords: [[fromNode.lat, fromNode.lng], [toNode.lat, toNode.lng]]
                    });
                }
                
                console.log(`Loaded ${railLines.length} rail line segments`);
                return railLines;
            } catch (error) {
                console.error('Error loading rail lines:', error);
                return [];
            }
        }
        
        // Draw rail nodes on map
        function drawRailNodes() {
            nodesLayer.clearLayers();
            
            // Get current zoom level to adjust visibility
            const zoom = map.getZoom();
            
            // Only show nodes when zoomed in enough (too many otherwise)
            if (zoom < 11) {
                // At low zoom, just show stations
                railNodes.filter(n => n.stationName).forEach(node => {
                    addNodeMarker(node, true);
                });
            } else if (zoom < 13) {
                // Medium zoom: show stations + sample of junctions
                railNodes.forEach((node, i) => {
                    if (node.stationName || node.boundary > 0 || i % 10 === 0) {
                        addNodeMarker(node, node.stationName);
                    }
                });
            } else {
                // High zoom: show all nodes
                railNodes.forEach(node => {
                    addNodeMarker(node, node.stationName);
                });
            }
        }
        
        // Add a single node marker
        function addNodeMarker(node, isStation) {
            let className, radius, color;
            
            if (node.stationName) {
                className = 'node-station';
                radius = 8;
                color = '#dc2626';
            } else if (node.boundary > 0) {
                className = 'node-boundary';
                radius = 5;
                color = '#0891b2';
            } else {
                className = 'node-marker';
                radius = 4;
                color = '#7c3aed';
            }
            
            const marker = L.circleMarker([node.lat, node.lng], {
                radius: radius,
                fillColor: color,
                color: '#fff',
                weight: 1.5,
                fillOpacity: 0.8,
                className: className
            }).addTo(nodesLayer);
            
            // Create popup content
            let nodeType = 'Junction';
            let badgeClass = 'badge-junction';
            if (node.stationName) {
                nodeType = 'Passenger Station';
                badgeClass = 'badge-station';
            } else if (node.boundary > 0) {
                nodeType = 'Boundary Point';
                badgeClass = 'badge-boundary';
            }
            
            marker.bindPopup(`
                <div class="node-popup">
                    <span class="node-type-badge ${badgeClass}">${nodeType}</span>
                    <h4>${node.stationName || 'Rail Junction'}</h4>
                    <div class="detail"><strong>Node ID:</strong> ${node.fraNodeId}</div>
                    <div class="detail"><strong>County FIPS:</strong> ${node.stCountyFips}</div>
                    <div class="detail"><strong>FRA District:</strong> ${node.fraDistrict}</div>
                    <div class="detail"><strong>Coords:</strong> ${node.lat.toFixed(4)}, ${node.lng.toFixed(4)}</div>
                    ${node.passenger ? `<div class="detail"><strong>Service:</strong> ${node.passenger}</div>` : ''}
                </div>
            `);
        }
        
        // Toggle node layer visibility
        function toggleNodeLayer() {
            const checkbox = document.getElementById('toggleNodes');
            const show = checkbox.checked;
            
            if (show) {
                // Show nodes
                if (railNodes.length === 0) {
                    loadRailNodes().then(() => {
                        drawRailNodes();
                        if (!map.hasLayer(nodesLayer)) {
                            map.addLayer(nodesLayer);
                        }
                    });
                } else {
                    drawRailNodes();
                    if (!map.hasLayer(nodesLayer)) {
                        map.addLayer(nodesLayer);
                    }
                }
            } else {
                // Hide nodes - remove layer from map
                nodesLayer.clearLayers();
                map.removeLayer(nodesLayer);
            }
        }
        
        // Redraw nodes on zoom change
        map.on('zoomend', function() {
            const checkbox = document.getElementById('toggleNodes');
            if (checkbox && checkbox.checked && map.hasLayer(nodesLayer)) {
                drawRailNodes();
            }
        });
        
        // ========== WEATHER API INTEGRATION ==========
        
        // Get weather icon emoji based on condition code
        function getWeatherIcon(code, isDay = true) {
            // OpenWeatherMap weather condition codes
            if (code >= 200 && code < 300) return '‚õàÔ∏è'; // Thunderstorm
            if (code >= 300 && code < 400) return 'üåßÔ∏è'; // Drizzle
            if (code >= 500 && code < 600) return 'üåßÔ∏è'; // Rain
            if (code >= 600 && code < 700) return '‚ùÑÔ∏è'; // Snow
            if (code >= 700 && code < 800) return 'üå´Ô∏è'; // Atmosphere (fog, mist, etc.)
            if (code === 800) return isDay ? '‚òÄÔ∏è' : 'üåô'; // Clear
            if (code === 801) return isDay ? 'üå§Ô∏è' : '‚òÅÔ∏è'; // Few clouds
            if (code === 802) return '‚õÖ'; // Scattered clouds
            if (code === 803 || code === 804) return '‚òÅÔ∏è'; // Broken/Overcast clouds
            return 'üå§Ô∏è';
        }
        
        // Format temperature
        function formatTemp(kelvin) {
            const celsius = kelvin - 273.15;
            const fahrenheit = (celsius * 9/5) + 32;
            return {
                f: Math.round(fahrenheit),
                c: Math.round(celsius)
            };
        }
        
        // Format wind speed
        function formatWindSpeed(ms) {
            const mph = ms * 2.237;
            return Math.round(mph);
        }
        
        // Get day name
        function getDayName(date) {
            const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            return days[date.getDay()];
        }
        
        // Load weather data
        async function loadWeatherData() {
            const weatherContent = document.getElementById('weatherContent');
            
            // If no API key, show demo data
            if (!WEATHER_API_KEY) {
                weatherContent.innerHTML = `
                    <div class="weather-current">
                        <div class="weather-icon">üå§Ô∏è</div>
                        <div class="temp">78¬∞F</div>
                        <div class="description">Partly Cloudy</div>
                        <div class="details">
                            <span>üí® Wind: 12 mph</span>
                            <span>üíß Humidity: 65%</span>
                        </div>
                        <div class="details">
                            <span>üëÅÔ∏è Visibility: 10 mi</span>
                            <span>üå°Ô∏è Feels: 80¬∞F</span>
                        </div>
                    </div>
                    <div style="margin-top:8px; padding:8px; background:#fffbeb; border-radius:4px; font-size:10px; color:#92400e;">
                        <strong>‚ö†Ô∏è Demo Mode:</strong> Add OpenWeatherMap API key for live data
                    </div>
                `;
                
                // Store demo forecast data for popup (temps in Kelvin for formatTemp function)
                // Convert Fahrenheit to Kelvin: K = (F - 32) * 5/9 + 273.15
                const fToK = (f) => (f - 32) * 5/9 + 273.15;
                const demoForecastDays = [
                    { date: new Date(), temps: [fToK(78), fToK(65)], conditions: [{ id: 801, description: 'partly cloudy', humidity: 65 }] },
                    { date: new Date(Date.now() + 86400000), temps: [fToK(82), fToK(68)], conditions: [{ id: 800, description: 'clear sky', humidity: 55 }] },
                    { date: new Date(Date.now() + 2*86400000), temps: [fToK(79), fToK(66)], conditions: [{ id: 802, description: 'scattered clouds', humidity: 60 }] },
                    { date: new Date(Date.now() + 3*86400000), temps: [fToK(75), fToK(64)], conditions: [{ id: 500, description: 'light rain', humidity: 80 }] },
                    { date: new Date(Date.now() + 4*86400000), temps: [fToK(81), fToK(67)], conditions: [{ id: 800, description: 'clear sky', humidity: 50 }] }
                ];
                storedForecastData = {
                    dailyForecast: {},
                    forecastDays: demoForecastDays
                };
                
                return;
            }
            
            weatherContent.innerHTML = '<div class="weather-loading">Loading weather data...</div>';
            
            try {
                // Fetch current weather and forecast
                const currentUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${WEATHER_LAT}&lon=${WEATHER_LON}&appid=${WEATHER_API_KEY}`;
                const forecastUrl = `https://api.openweathermap.org/data/2.5/forecast?lat=${WEATHER_LAT}&lon=${WEATHER_LON}&appid=${WEATHER_API_KEY}`;
                
                const [currentResponse, forecastResponse] = await Promise.all([
                    fetch(currentUrl),
                    fetch(forecastUrl)
                ]);
                
                if (!currentResponse.ok || !forecastResponse.ok) {
                    throw new Error('Weather API error');
                }
                
                const currentData = await currentResponse.json();
                const forecastData = await forecastResponse.json();
                
                // Format current weather
                const temp = formatTemp(currentData.main.temp);
                const feelsLike = formatTemp(currentData.main.feels_like);
                const windSpeed = formatWindSpeed(currentData.wind.speed);
                const isDay = currentData.dt > currentData.sys.sunrise && currentData.dt < currentData.sys.sunset;
                const icon = getWeatherIcon(currentData.weather[0].id, isDay);
                
                // Build current weather HTML
                let currentHtml = `
                    <div class="weather-current">
                        <div class="weather-icon">${icon}</div>
                        <div class="temp">${temp.f}¬∞F</div>
                        <div class="description">${currentData.weather[0].description}</div>
                        <div class="details">
                            <span>üí® Wind: ${windSpeed} mph ${currentData.wind.deg ? `(${currentData.wind.deg}¬∞)` : ''}</span>
                            <span>üíß Humidity: ${currentData.main.humidity}%</span>
                        </div>
                        <div class="details">
                            <span>üëÅÔ∏è Visibility: ${currentData.visibility ? (currentData.visibility / 1609.34).toFixed(1) : 'N/A'} mi</span>
                            <span>üå°Ô∏è Feels: ${feelsLike.f}¬∞F</span>
                        </div>
                        <div class="details" style="margin-top:4px;">
                            <span>üìä Pressure: ${currentData.main.pressure} hPa</span>
                            <span>‚òÅÔ∏è Clouds: ${currentData.clouds.all}%</span>
                        </div>
                    </div>
                `;
                
                // Group forecast by day and get max/min temps for popup
                const dailyForecast = {};
                forecastData.list.forEach(item => {
                    const date = new Date(item.dt * 1000);
                    const dayKey = date.toDateString();
                    
                    if (!dailyForecast[dayKey]) {
                        dailyForecast[dayKey] = {
                            date: date,
                            temps: [],
                            conditions: [],
                            icons: []
                        };
                    }
                    
                    dailyForecast[dayKey].temps.push(item.main.temp_max, item.main.temp_min);
                    dailyForecast[dayKey].conditions.push(item.weather[0]);
                    dailyForecast[dayKey].icons.push(getWeatherIcon(item.weather[0].id, true));
                });
                
                // Only show current weather in panel
                weatherContent.innerHTML = currentHtml;
                
                // Store forecast data for popup
                storedForecastData = {
                    dailyForecast: dailyForecast,
                    forecastDays: Object.values(dailyForecast).slice(0, 5)
                };
                
            } catch (error) {
                console.error('Weather API error:', error);
                weatherContent.innerHTML = `
                    <div class="weather-error">
                        ‚ö†Ô∏è Unable to load weather data<br>
                        <small>Check API key or network connection</small>
                    </div>
                `;
            }
        }
        
        // Toggle rain/precipitation overlay on map
        function toggleRainOverlay() {
            const checkbox = document.getElementById('toggleRainOverlay');
            const show = checkbox.checked;
            
            if (show) {
                // Remove existing overlay if any
                if (rainOverlayLayer && map.hasLayer(rainOverlayLayer)) {
                    map.removeLayer(rainOverlayLayer);
                    rainOverlayLayer = null;
                }
                
                // Create rain overlay layer
                if (WEATHER_API_KEY) {
                    // Use OpenWeatherMap precipitation layer (best quality, requires API key)
                    rainOverlayLayer = L.tileLayer(`https://tile.openweathermap.org/map/precipitation_new/{z}/{x}/{y}.png?appid=${WEATHER_API_KEY}`, {
                        attribution: 'Rain data ¬© OpenWeatherMap',
                        opacity: 0.65,
                        maxZoom: 19
                    });
                } else {
                    // Use RainViewer API (free, no key required)
                    // Get latest available timestamp (rounded to nearest 10 minutes)
                    const now = Math.floor(Date.now() / 1000);
                    const roundedTime = Math.floor(now / 600) * 600; // Round to nearest 10 minutes
                    
                    rainOverlayLayer = L.tileLayer(`https://tilecache.rainviewer.com/v2/radar/${roundedTime}/256/{z}/{x}/{y}/2/1_1.png`, {
                        attribution: 'Rain data ¬© RainViewer.com',
                        opacity: 0.7,
                        maxZoom: 19,
                        errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
                    });
                }
                
                // Add overlay to map
                rainOverlayLayer.addTo(map);
                
                // Show forecast popup
                showForecastPopup();
            } else {
                // Remove overlay from map
                if (rainOverlayLayer && map.hasLayer(rainOverlayLayer)) {
                    map.removeLayer(rainOverlayLayer);
                }
                
                // Hide forecast popup
                closeForecastPopup();
            }
        }
        
        // Show forecast popup
        function showForecastPopup() {
            const popup = document.getElementById('forecastPopup');
            const overlay = document.getElementById('forecastOverlay');
            const content = document.getElementById('forecastPopupContent');
            
            // Generate forecast content
            if (storedForecastData && storedForecastData.forecastDays) {
                let popupHtml = '<div class="forecast-popup-grid">';
                
                storedForecastData.forecastDays.forEach((day, index) => {
                    const maxTemp = formatTemp(Math.max(...day.temps));
                    const minTemp = formatTemp(Math.min(...day.temps));
                    const mainCondition = day.conditions[Math.floor(day.conditions.length / 2)];
                    const mainIcon = getWeatherIcon(mainCondition.id, true);
                    
                    let dayLabel;
                    if (index === 0) {
                        dayLabel = 'Today';
                    } else if (index === 1) {
                        dayLabel = 'Tomorrow';
                    } else {
                        dayLabel = getDayName(day.date);
                    }
                    
                    // Get additional details from forecast
                    const avgHumidity = day.conditions.length > 0 ? 
                        (day.conditions.reduce((sum, c) => sum + (c.humidity || 0), 0) / day.conditions.length).toFixed(0) : 'N/A';
                    
                    popupHtml += `
                        <div class="forecast-popup-item">
                            <div class="day">${dayLabel}</div>
                            <div class="icon">${mainIcon}</div>
                            <div class="temp">${maxTemp.f}¬∞ / ${minTemp.f}¬∞</div>
                            <div class="desc">${mainCondition.description}</div>
                            <div class="details">
                                ${day.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                            </div>
                        </div>
                    `;
                });
                
                popupHtml += '</div>';
                content.innerHTML = popupHtml;
            } else {
                // No forecast data available - try to load it
                content.innerHTML = '<div class="weather-loading">Loading forecast data...<br><small>Please wait or refresh weather data first</small></div>';
                // Try to load weather data if not already loaded
                if (!storedForecastData) {
                    loadWeatherData().then(() => {
                        // Retry showing popup after data loads
                        setTimeout(showForecastPopup, 500);
                    });
                }
            }
            
            // Show popup and overlay
            popup.classList.add('show');
            overlay.classList.add('show');
        }
        
        // Close forecast popup
        function closeForecastPopup() {
            const popup = document.getElementById('forecastPopup');
            const overlay = document.getElementById('forecastOverlay');
            popup.classList.remove('show');
            overlay.classList.remove('show');
        }
        
        // Initialize rail network (async - loads from CSV)
        loadRailNodes().then(() => {
            drawRailNetwork();
        });
        
        // Load initial data
        loadAISData();
        loadWeatherData();
        
        // ========== AI ANALYTICS INTEGRATION ==========
        
        // API Configuration - adjust if running on different port
        const API_BASE_URL = 'http://localhost:5000';
        
        // Check API status and update indicator
        async function checkAPIStatus() {
            const statusDot = document.getElementById('aiStatusDot');
            try {
                const response = await fetch(`${API_BASE_URL}/api/health`, { 
                    signal: AbortSignal.timeout(3000) 
                });
                if (response.ok) {
                    statusDot.className = 'status-dot';
                    return true;
                }
            } catch (e) {
                console.log('API not available:', e.message);
            }
            statusDot.className = 'status-dot offline';
            return false;
        }
        
        // Refresh metrics from API
        async function refreshMetrics() {
            const statusDot = document.getElementById('aiStatusDot');
            statusDot.className = 'status-dot loading';
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/metrics`);
                if (!response.ok) throw new Error('API error');
                
                const metrics = await response.json();
                
                // Update display
                document.getElementById('metricTeu').textContent = `${metrics.current_teu_per_hour} TEU`;
                document.getElementById('metricDeviation').textContent = `${metrics.percent_deviation > 0 ? '+' : ''}${metrics.percent_deviation}%`;
                
                const riskEl = document.getElementById('metricRisk');
                riskEl.textContent = metrics.surge_risk;
                riskEl.className = `metric-value risk-${metrics.surge_risk.toLowerCase()}`;
                
                document.getElementById('metricVessels').textContent = metrics.vessels_in_channel;
                
                statusDot.className = 'status-dot';
            } catch (e) {
                console.error('Failed to fetch metrics:', e);
                statusDot.className = 'status-dot offline';
                
                // Show demo data if API unavailable
                document.getElementById('metricTeu').textContent = '~175 TEU';
                document.getElementById('metricDeviation').textContent = '+20%';
                document.getElementById('metricRisk').textContent = 'MEDIUM';
                document.getElementById('metricRisk').className = 'metric-value risk-medium';
                document.getElementById('metricVessels').textContent = '~25';
            }
        }
        
        // Add message to chat area
        function addChatMessage(content, type = 'assistant') {
            const chatArea = document.getElementById('aiChatArea');
            const msg = document.createElement('div');
            msg.className = `ai-message ${type}`;
            msg.textContent = content;
            chatArea.appendChild(msg);
            chatArea.scrollTop = chatArea.scrollHeight;
        }
        
        // Send message to AI
        async function sendAIMessage() {
            const input = document.getElementById('aiInput');
            const sendBtn = document.getElementById('aiSendBtn');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            addChatMessage(message, 'user');
            input.value = '';
            sendBtn.disabled = true;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message }),
                    signal: AbortSignal.timeout(60000)
                });
                
                if (!response.ok) throw new Error('API error');
                
                const data = await response.json();
                addChatMessage(data.response, 'assistant');
                
                // Update metrics if included
                if (data.metrics) {
                    document.getElementById('metricTeu').textContent = `${data.metrics.current_teu_per_hour} TEU`;
                    document.getElementById('metricDeviation').textContent = `${data.metrics.percent_deviation > 0 ? '+' : ''}${data.metrics.percent_deviation}%`;
                    const riskEl = document.getElementById('metricRisk');
                    riskEl.textContent = data.metrics.surge_risk;
                    riskEl.className = `metric-value risk-${data.metrics.surge_risk.toLowerCase()}`;
                }
            } catch (e) {
                console.error('AI chat error:', e);
                addChatMessage('Could not connect to AI. Make sure the API server is running (python api_server.py)', 'error');
            }
            
            sendBtn.disabled = false;
        }
        
        // Quick ask button handler
        function askAI(question) {
            document.getElementById('aiInput').value = question;
            sendAIMessage();
        }
        
        // Initialize AI panel
        checkAPIStatus();
        refreshMetrics();
        
        // Refresh metrics every 60 seconds
        setInterval(refreshMetrics, 60000);
    </script>
</body>
</html>
